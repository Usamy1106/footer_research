<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4x4 Grid Image Analyzer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s ease;
            background: #f8f9ff;
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: #f0f2ff;
        }

        .upload-area.dragover {
            border-color: #764ba2;
            background: #e8ecff;
        }

        input[type="file"] {
            margin: 20px 0;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
        }

        .preview-container {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
        }

        .image-preview,
        .grid-preview {
            flex: 1;
        }

        .image-preview img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }

        .grid-visualization {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            border: 2px solid #333;
            padding: 20px;
            background: #f9f9f9;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .grid-cell {
            aspect-ratio: 1;
            border: 2px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            text-align: center;
            background: white;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .grid-cell.logo-span {
            background: #e3f2fd;
            border-color: #1976d2;
            font-weight: bold;
            position: relative;
        }

        .grid-cell.span-continuation {
            background: #e8f5e8;
            border-color: #4caf50;
            font-size: 10px;
            opacity: 0.7;
        }

        .code-output {
            background: #1e1e1e;
            color: #fff;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .analyze-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: block;
            margin: 0 auto;
        }

        .analyze-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .camera-button,
        .capture-button,
        .stop-camera-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            margin: 10px 5px;
            transition: all 0.3s ease;
        }

        .camera-button:hover,
        .capture-button:hover,
        .stop-camera-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        #cameraContainer {
            margin-top: 20px;
            text-align: center;
        }

        #cameraVideo {
            border: 3px solid #667eea;
            border-radius: 10px;
            object-fit: cover;
        }

        .camera-controls {
            margin-top: 15px;
        }

        .status {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-weight: bold;
        }

        .status.success {
            background: #e8f5e8;
            color: #2e7d32;
            border: 2px solid #4caf50;
        }

        .status.error {
            background: #fce8e6;
            color: #c62828;
            border: 2px solid #f44336;
        }

        .status.info {
            background: #e3f2fd;
            color: #1565c0;
            border: 2px solid #2196f3;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>🎯 4x4 Grid Image Analyzer</h1>

        <div class="upload-area" id="uploadArea">
            <h3>📁 画像をアップロード または 📷 カメラで撮影</h3>
            <p>4x4グリッドレイアウトの画像をドラッグ&ドロップ、選択、またはカメラで撮影してください</p>
            <input type="file" id="imageInput" accept="image/*,.heic,.heif">
            <button class="camera-button" id="cameraButton">📷 カメラを起動</button>

            <div id="cameraContainer" style="display: none;">
                <video id="cameraVideo" width="400" height="400" autoplay></video>
                <canvas id="cameraCanvas" width="400" height="400" style="display: none;"></canvas>
                <div class="camera-controls">
                    <button class="capture-button" id="captureButton">📸 撮影</button>
                    <button class="stop-camera-button" id="stopCameraButton">❌ カメラ停止</button>
                </div>
            </div>
        </div>

        <div id="status" class="status" style="display: none;"></div>

        <div class="preview-container" id="previewContainer" style="display: none;">
            <div class="image-preview">
                <h3>📷 アップロード画像</h3>
                <img id="uploadedImage" alt="Uploaded image">
            </div>
            <div class="grid-preview">
                <h3>🎯 検出結果</h3>
                <div class="grid-visualization" id="gridVisualization"></div>
                <button class="analyze-button" id="analyzeButton">🔍 画像を解析</button>
            </div>
        </div>

        <div id="codeContainer" style="display: none;">
            <h3>💻 生成されたCSSグリッドコード</h3>
            <div class="code-output" id="codeOutput"></div>
        </div>
    </div>

    <script>
        // 画像認識用のパターンマッチング辞書
        const contentPatterns = {
            'logo-center': ['logo', 'ロゴ', 'LOGO'],
            'logo-left': ['logo', 'ロゴ', 'LOGO'],
            'sns': ['facebook', 'twitter', 'instagram', 'x', 'sns', 'SNS', 'f', 'ig'],
            'home': ['home', 'ホーム', 'HOME'],
            'terms': ['利用規約', '規約', 'terms'],
            'sitemap': ['サイトマップ', 'sitemap', 'SITEMAP'],
            'privacy': ['プライバシーポリシー', 'privacy', 'プライバシー', 'ポリシー'],
            'phone': ['tel', 'TEL', '042', '637', '8111', '電話'],
            'copyright': ['©', 'copyright', '2025', '©2025'],
            'content_group': ['コンテンツ', 'content'],
            'support_group': ['サポート', 'support'],
            'policy_group': ['ポリシー', 'policy'],
            // 簡略化のため、ナビゲーション要素は分類しない
        };

        // カメラ関連の変数
        let cameraStream = null;
        let cameraVideo = null;
        let cameraCanvas = null;
        let cameraContext = null;

        // DOM要素の取得
        const uploadArea = document.getElementById('uploadArea');
        const imageInput = document.getElementById('imageInput');
        const uploadedImage = document.getElementById('uploadedImage');
        const previewContainer = document.getElementById('previewContainer');
        const gridVisualization = document.getElementById('gridVisualization');
        const analyzeButton = document.getElementById('analyzeButton');
        const codeContainer = document.getElementById('codeContainer');
        const codeOutput = document.getElementById('codeOutput');
        const status = document.getElementById('status');
        const cameraButton = document.getElementById('cameraButton');
        const cameraContainer = document.getElementById('cameraContainer');
        const cameraVideoElement = document.getElementById('cameraVideo');
        const captureButton = document.getElementById('captureButton');
        const stopCameraButton = document.getElementById('stopCameraButton');
        const cameraCanvasElement = document.getElementById('cameraCanvas');

        // グリッドの状態を保存
        let gridData = Array(16).fill(null);
        let currentImage = null;

        // ステータス表示関数
        function showStatus(message, type = 'info') {
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';

            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    status.style.display = 'none';
                }, 3000);
            }
        }

        // グリッド可視化の初期化
        function initializeGrid() {
            gridVisualization.innerHTML = '';
            for (let i = 0; i < 16; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.textContent = `${i + 1}`;
                cell.dataset.index = i;
                gridVisualization.appendChild(cell);
            }
        }

        // --- ★ HEIC対応ライブラリの読み込み（libheif-jsに再切り替え）★ ---
        async function loadHeifLibrary() {
            return new Promise((resolve, reject) => {
                if (window.HeifImage) {
                    resolve(window.HeifImage);
                    return;
                }

                const script = document.createElement('script');
                // libheif-js のCDNを使用
                script.src = 'https://cdn.jsdelivr.net/npm/libheif-js@1.17.1/libheif-bundle.min.js';
                script.onload = () => {
                    if (window.HeifImage) {
                        resolve(window.HeifImage);
                    } else {
                        reject(new Error('HEICライブラリが見つかりませんでした。'));
                    }
                };
                script.onerror = (error) => {
                    console.error('HEICライブラリの読み込みエラー:', error);
                    reject(new Error('HEICライブラリの読み込みに失敗しました。'));
                };
                document.head.appendChild(script);
            });
        }

        // --- ★ ファイルアップロード処理（HEIC対応修正版 - libheif-jsを使用）★ ---
        async function handleFile(file) {
            if (!file.type.startsWith('image/') &&
                !file.name.toLowerCase().endsWith('.heic') &&
                !file.name.toLowerCase().endsWith('.heif')) {
                showStatus('対応していないファイル形式です。画像ファイルまたはHEICファイルを選択してください。', 'error');
                return;
            }

            let processedFile = file;
            let isHeic = file.name.toLowerCase().endsWith('.heic') || file.name.toLowerCase().endsWith('.heif');

            // HEIC/HEIF形式の変換
            if (isHeic) {
                try {
                    showStatus('HEIC変換用ライブラリを読み込み中...', 'info');
                    const HeifImage = await loadHeifLibrary();

                    showStatus('HEIC画像をデコード中...', 'info');
                    const buffer = await file.arrayBuffer();

                    const decoder = new HeifImage.HeifDecoder();
                    const images = decoder.decode(buffer);

                    if (images.length === 0) {
                        throw new Error("HEICファイルから画像をデコードできませんでした。");
                    }

                    // 最初の画像をCanvasに描画してJPEG Blobに変換
                    const image = images[0];
                    const canvas = document.createElement('canvas');
                    canvas.width = image.get_width();
                    canvas.height = image.get_height();
                    const ctx = canvas.getContext('2d');

                    const imageData = ctx.createImageData(canvas.width, canvas.height);
                    imageData.data.set(new Uint8ClampedArray(image.get_data()));
                    ctx.putImageData(imageData, 0, 0);

                    processedFile = await new Promise(resolve => {
                        canvas.toBlob(resolve, 'image/jpeg', 0.9);
                    });

                    showStatus('HEIC変換完了。画像を読み込み中...', 'success');
                } catch (error) {
                    console.error('HEIC変換エラー:', error);
                    showStatus(`HEIC変換に失敗しました: ${error.message ? error.message : 'ファイル解析エラー'}。ファイルが破損しているか、未対応のHEIC形式の可能性があります。`, 'error');
                    return;
                }
            }

            const reader = new FileReader();
            reader.onload = function (e) {
                currentImage = e.target.result;
                uploadedImage.src = currentImage;
                previewContainer.style.display = 'block';
                initializeGrid();
                showStatus('画像が読み込まれました。解析ボタンをクリックしてください。', 'success');
            };
            reader.onerror = function () {
                showStatus('ファイル読み込みに失敗しました。', 'error');
            };
            reader.readAsDataURL(processedFile);
        }

        // カメラ起動
        async function startCamera() {
            try {
                showStatus('カメラを起動中...', 'info');
                cameraStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: {
                            ideal: 400
                        },
                        height: {
                            ideal: 400
                        },
                        aspectRatio: 1.0,
                        facingMode: 'environment' // 背面カメラを優先
                    }
                });

                cameraVideo = cameraVideoElement;
                cameraCanvas = cameraCanvasElement;
                cameraContext = cameraCanvas.getContext('2d');

                cameraVideo.srcObject = cameraStream;
                cameraContainer.style.display = 'block';
                cameraButton.style.display = 'none';

                showStatus('カメラが起動しました。撮影ボタンを押してください。', 'success');
            } catch (error) {
                console.error('Camera error:', error);
                showStatus('カメラの起動に失敗しました。ファイルアップロードをご利用ください。', 'error');
            }
        }

        // 写真撮影
        function capturePhoto() {
            if (!cameraStream) return;

            cameraContext.drawImage(cameraVideo, 0, 0, 400, 400);
            cameraCanvas.toBlob(function (blob) {
                const file = new File([blob], 'camera-capture.jpg', {
                    type: 'image/jpeg'
                });
                handleFile(file);
                stopCamera();
            }, 'image/jpeg', 0.9);
        }

        // カメラ停止
        function stopCamera() {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }
            cameraContainer.style.display = 'none';
            cameraButton.style.display = 'inline-block';
            showStatus('カメラを停止しました。', 'info');
        }

        // 2段階画像解析：余白検出 → コンテンツ検出
        function simulateAdvancedTextDetection(canvas) {
            return new Promise((resolve) => {
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                setTimeout(() => {
                    console.log('Phase 1: 余白検出を開始...');

                    // Phase 1: 余白領域を特定
                    const emptyAreas = detectEmptyAreas(imageData, canvas.width, canvas.height);

                    console.log('Phase 2: コンテンツ検出を開始...');

                    // Phase 2: 余白以外の領域でコンテンツを検出
                    const contentAreas = detectContentAreas(imageData, canvas.width, canvas.height, emptyAreas);

                    console.log(`検出完了: ${contentAreas.length}個のコンテンツ候補を発見`);

                    resolve(contentAreas); // 生のコンテンツ候補を返す
                }, 1500);
            });
        }

        // Phase 1: 余白領域の検出（変更なし）
        function detectEmptyAreas(imageData, width, height) {
            const data = imageData.data;
            const emptyGrids = new Set();

            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    const cellKey = `${row}-${col}`;

                    if (row === 3) continue; // 最下段はスキップ

                    const isEmpty = analyzeCellForEmptiness(data, width, height, row, col);

                    if (isEmpty.confidence > 0.85) {
                        emptyGrids.add(cellKey);
                    }
                }
            }
            return emptyGrids;
        }

        // セルの余白判定（変更なし）
        function analyzeCellForEmptiness(data, width, height, row, col) {
            const cellWidth = Math.floor(width / 4);
            const cellHeight = Math.floor(height / 4);
            const startX = col * cellWidth;
            const startY = row * cellHeight;
            const endX = Math.min(startX + cellWidth, width);
            const endY = Math.min(startY + cellHeight, height);

            let backgroundPixels = 0;
            let contentPixels = 0;
            let totalPixels = 0;
            const colorCounts = new Map();
            const brightnessValues = [];

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const i = (y * width + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const brightness = (r + g + b) / 3;

                    totalPixels++;
                    brightnessValues.push(brightness);

                    if (isLikelyBackground(r, g, b)) {
                        backgroundPixels++;
                    } else {
                        contentPixels++;
                    }

                    const colorKey = `${Math.floor(r / 15)}-${Math.floor(g / 15)}-${Math.floor(b / 15)}`;
                    colorCounts.set(colorKey, (colorCounts.get(colorKey) || 0) + 1);
                }
            }

            const backgroundRatio = backgroundPixels / totalPixels;
            const contentRatio = contentPixels / totalPixels;
            const avgBrightness = brightnessValues.reduce((a, b) => a + b, 0) / brightnessValues.length;
            const brightnessVariance = brightnessValues.reduce((acc, val) => acc + Math.pow(val - avgBrightness, 2), 0) / brightnessValues.length;
            const brightnessStdDev = Math.sqrt(brightnessVariance);
            const uniqueColors = colorCounts.size;
            const maxExpectedColors = Math.max(totalPixels / 100, 10);
            const colorUniformity = Math.max(0, 1 - (uniqueColors / maxExpectedColors));
            const brightnessUniformity = Math.max(0, 1 - (brightnessStdDev / 80));

            const emptyConfidence = (
                backgroundRatio * 0.6 +
                colorUniformity * 0.25 +
                brightnessUniformity * 0.15
            ) - (contentRatio * 0.2);

            return {
                confidence: Math.max(0, Math.min(emptyConfidence, 1.0)),
                backgroundRatio,
                contentRatio,
                colorUniformity,
                brightnessUniformity,
                uniqueColors,
                avgBrightness
            };
        }

        // 背景色の可能性判定（変更なし）
        function isLikelyBackground(r, g, b) {
            const isWhitish = (r > 230 && g > 230 && b > 230);
            const isGrayish = (
                Math.abs(r - g) < 25 && Math.abs(g - b) < 25 &&
                r > 180 && g > 180 && b > 180
            );
            const isWoodish = (
                r >= 120 && r <= 220 &&
                g >= 100 && g <= 190 &&
                b >= 80 && b <= 160 &&
                (r - g) > -20 && (r - g) < 50 &&
                (g - b) > -10 && (g - b) < 60
            );
            const isBeigeish = (
                r >= 200 && r <= 255 &&
                g >= 190 && g <= 240 &&
                b >= 170 && b <= 220 &&
                Math.abs(r - g) < 30 && Math.abs(g - b) < 30
            );

            return isWhitish || isGrayish || isWoodish || isBeigeish;
        }

        // Phase 2: コンテンツ領域の検出（ロジックをより厳密に）
        function detectContentAreas(imageData, width, height, emptyAreas) {
            const data = imageData.data;
            const contentAreas = [];

            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    const cellKey = `${row}-${col}`;

                    if (emptyAreas.has(cellKey)) {
                        continue;
                    }

                    const contentAnalysis = analyzeContentInCell(data, width, height, row, col);

                    // 検出信頼度を0.3以上に厳しく設定
                    if (contentAnalysis.hasContent && contentAnalysis.confidence > 0.3) {
                        contentAreas.push({
                            row,
                            col,
                            position: {
                                x: (col + 0.5) / 4,
                                y: (row + 0.5) / 4
                            },
                            ...contentAnalysis
                        });
                    }
                }
            }
            return contentAreas;
        }

        // セル内のコンテンツ分析（ロゴ・テキストの検出基準を厳密化）
        function analyzeContentInCell(data, width, height, row, col) {
            const cellWidth = Math.floor(width / 4);
            const cellHeight = Math.floor(height / 4);
            const startX = col * cellWidth;
            const startY = row * cellHeight;
            const endX = Math.min(startX + cellWidth, width);
            const endY = Math.min(startY + cellHeight, height);

            let darkPixels = 0;
            let edgePixels = 0;
            let textLikeRegions = 0;
            let logoLikeRegions = 0;
            let nonBackgroundPixels = 0;
            const totalPixels = (endX - startX) * (endY - startY);

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const i = (y * width + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const brightness = (r + g + b) / 3;

                    if (!isLikelyBackground(r, g, b)) {
                        nonBackgroundPixels++;

                        if (brightness < 160) { // 基準を180→160に厳しく
                            darkPixels++;

                            if (hasLogoLikePattern(data, width, x, y)) {
                                logoLikeRegions++;
                            }

                            if (hasTextLikePattern(data, width, x, y)) {
                                textLikeRegions++;
                            }
                        }
                    }

                    if (detectMediumEdge(data, width, x, y)) {
                        edgePixels++;
                    }
                }
            }

            const darkRatio = darkPixels / totalPixels;
            const edgeRatio = edgePixels / totalPixels;
            const textRatio = textLikeRegions / totalPixels;
            const logoRatio = logoLikeRegions / totalPixels;
            const nonBgRatio = nonBackgroundPixels / totalPixels;

            let contentType = 'unknown';
            let hasContent = false;
            let confidence = 0;

            if (nonBgRatio > 0.05) { // 背景でない画素が5%以上（厳しく）
                hasContent = true;

                // ロゴ判定: 上段で塊状の濃い領域が多い
                if ((row === 0 || row === 1) && logoRatio > 0.015) { // 閾値を上げる
                    contentType = 'logo';
                    confidence = Math.min((logoRatio * 30) + (darkRatio * 10), 1.0);
                }
                // テキスト判定: エッジとテキストパターンが多い
                else if (textRatio > 0.01 || edgeRatio > 0.03) {
                    contentType = 'text';
                    confidence = Math.min((textRatio * 40) + (edgeRatio * 15) + (darkRatio * 5), 1.0);
                }
                // グラフィック判定: 図形的な要素が多い
                else if (edgeRatio > 0.02) {
                    contentType = 'graphic';
                    confidence = Math.min((edgeRatio * 15) + (darkRatio * 8), 1.0);
                }
                // その他
                else {
                    contentType = 'mixed';
                    confidence = Math.min(nonBgRatio * 8, 1.0);
                }

                // 信頼度を最低保証
                confidence = Math.max(confidence, nonBgRatio * 5);
            }

            // 最終チェック：信頼度が0.3未満ならコンテンツと見なさない
            if (confidence < 0.3) {
                hasContent = false;
            }

            return {
                hasContent,
                confidence,
                contentType,
                darkRatio,
                edgeRatio,
                textRatio,
                logoRatio,
                nonBgRatio
            };
        }

        // 中程度のエッジ検出（変更なし）
        function detectMediumEdge(data, width, x, y) {
            if (x <= 0 || x >= width - 1 || y <= 0) return false;

            const current = (y * width + x) * 4;
            const right = (y * width + (x + 1)) * 4;
            const down = ((y + 1) * width + x) * 4;

            const currentBrightness = (data[current] + data[current + 1] + data[current + 2]) / 3;
            const rightBrightness = (data[right] + data[right + 1] + data[right + 2]) / 3;
            const downBrightness = (data[down] + data[down + 1] + data[down + 2]) / 3;

            const horizontalDiff = Math.abs(currentBrightness - rightBrightness);
            const verticalDiff = Math.abs(currentBrightness - downBrightness);

            return horizontalDiff > 40 || verticalDiff > 40;
        }

        // ロゴっぽいパターンの検出（変更なし）
        function hasLogoLikePattern(data, width, x, y) {
            const centerI = (y * width + x) * 4;
            const centerBrightness = (data[centerI] + data[centerI + 1] + data[centerI + 2]) / 3;

            if (centerBrightness > 120) return false;

            let similarDarkPixels = 0;
            const radius = 3;

            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < width && ny >= 0) {
                        const ni = (ny * width + nx) * 4;
                        const neighborBrightness = (data[ni] + data[ni + 1] + data[ni + 2]) / 3;

                        if (Math.abs(centerBrightness - neighborBrightness) < 40 && neighborBrightness < 150) {
                            similarDarkPixels++;
                        }
                    }
                }
            }

            return similarDarkPixels >= 12;
        }

        // テキストっぽいパターンの検出（変更なし）
        function hasTextLikePattern(data, width, x, y) {
            const centerI = (y * width + x) * 4;
            const centerBrightness = (data[centerI] + data[centerI + 1] + data[centerI + 2]) / 3;

            let contrastCount = 0;
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [1, 1], [-1, 1], [1, -1]];

            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                const ni = (ny * width + nx) * 4;
                const neighborBrightness = (data[ni] + data[ni + 1] + data[ni + 2]) / 3;

                if (Math.abs(centerBrightness - neighborBrightness) > 60) {
                    contrastCount++;
                }
            }

            return contrastCount >= 3;
        }


        // --- ★ 新しい後処理：検出結果の結合と最終分類（位置による決め打ちを排除）★ ---
        function postProcessDetections(contentAreas) {
            const processedDetections = [];
            const occupiedCells = new Set();
            // グリッドを初期化し、検出されたコンテンツ候補を配置
            const grid = contentAreas.reduce((acc, det) => {
                const index = det.row * 4 + det.col;
                acc[index] = { ...det, colspan: 1 };
                return acc;
            }, Array(16).fill(null));


            // 1. 隣接するコンテンツ候補の結合
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    const index = row * 4 + col;
                    const det = grid[index];

                    if (!det || occupiedCells.has(index)) continue;

                    let currentColspan = 1;

                    // ロゴ候補（上2段にある）かつ隣のセルがある場合
                    if ((row === 0 || row === 1) && det.contentType === 'logo' && col <= 2) {
                        const neighborIndex = index + 1;
                        const neighbor = grid[neighborIndex];

                        // 隣のセルもロゴ候補であれば結合
                        if (neighbor && neighbor.contentType === 'logo' && !occupiedCells.has(neighborIndex)) {
                            currentColspan = 2;
                            occupiedCells.add(neighborIndex);
                        }
                    }

                    det.colspan = currentColspan;
                    occupiedCells.add(index);
                    processedDetections.push(det);
                }
            }

            // 2. 結合後の最終分類（コンテンツタイプは位置に紐づく一般的なフッター要素に分類）
            processedDetections.forEach(det => {
                // ロゴ要素の決定
                if (det.contentType === 'logo') {
                    det.text = det.colspan === 2 ? 'Logo (2 Columns)' : 'Logo (Single)';
                    det.contentType = det.colspan === 2 ? 'logo-center' : 'logo-left';
                    return;
                }

                // 2段目（サービス/コンテンツのセクション）
                if (det.row === 1) {
                    const groupMap = ['コンテンツ', 'サポート', 'ポリシー', 'ナビ'];
                    const typeMap = ['content_group', 'support_group', 'policy_group', 'nav_link'];
                    det.text = groupMap[det.col] || 'Nav Link';
                    det.contentType = typeMap[det.col] || 'nav_link';
                    return;
                }

                // 3段目（主要リンク）
                if (det.row === 2) {
                    const footerMap = ['Home', 'サイトマップ', 'プライバシーポリシー', '利用規約'];
                    const typeMap = ['home', 'sitemap', 'privacy', 'terms'];
                    det.text = footerMap[det.col] || 'Nav Link';
                    det.contentType = typeMap[det.col] || 'nav_link';
                    return;
                }

                // 4段目（ボトム情報）
                if (det.row === 3) {
                    if (det.col === 0) {
                        det.text = 'SNS Icons';
                        det.contentType = 'sns';
                    } else if (det.col === 1) {
                        det.text = 'TEL. 042-637-8111';
                        det.contentType = 'phone';
                    } else if (det.col === 2) {
                        det.text = '© 2025 Logo';
                        det.contentType = 'copyright';
                    } else {
                        det.text = 'Custom Info';
                        det.contentType = 'other';
                    }
                    return;
                }

                // 上段でロゴでもないテキスト要素
                if (det.row === 0 && det.contentType === 'text') {
                    det.text = 'Main Nav Link';
                    det.contentType = 'nav_link';
                    return;
                }

                det.text = '不明なコンテンツ';
                det.contentType = 'other';
            });

            return processedDetections;
        }

        // 位置から4x4グリッドのインデックス計算（簡略化：使わない）
        function getGridIndexAdvanced(x, y, width = 0.25, height = 0.25, text = '') {
            // この関数は新しいロジックでは使用しないが、互換性のために残す
            const col = Math.floor(x * 4);
            const row = Math.floor(y * 4);
            const baseIndex = Math.min(row * 4 + col, 15);

            return {
                index: baseIndex,
                colspan: 1,
                rowspan: 1,
                type: 'single'
            };
        }

        // テキストからコンテンツタイプを判定（使用頻度は下がるが残す）
        function classifyContent(text) {
            const lowerText = text.toLowerCase();

            for (const [contentType, patterns] of Object.entries(contentPatterns)) {
                for (const pattern of patterns) {
                    if (lowerText.includes(pattern.toLowerCase())) {
                        return contentType;
                    }
                }
            }
            return 'other';
        }

        // 実際の画像解析（高精度版）
        async function analyzeImageContent() {
            if (!currentImage) {
                showStatus('画像が選択されていません。', 'error');
                return;
            }

            showStatus('高精度画像解析を実行中（硬直ロジック修正済み）...', 'info');
            analyzeButton.disabled = true;

            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();

                img.onload = async () => {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);

                    // 1. 画像特徴検出（コンテンツ候補リストを取得）
                    const contentAreas = await simulateAdvancedTextDetection(canvas);

                    // 2. 後処理、結合、最終分類（新しいロジック）
                    const detectedTexts = postProcessDetections(contentAreas);

                    // グリッドデータをリセット
                    gridData = Array(16).fill(null);

                    // 3. グリッドへの反映
                    detectedTexts.forEach(detection => {
                        const index = detection.row * 4 + detection.col;

                        const gridEntry = {
                            type: detection.contentType,
                            originalText: detection.text,
                            colspan: detection.colspan,
                            rowspan: 1,
                            confidence: detection.confidence || 0.8
                        };

                        gridData[index] = gridEntry;

                        // 2列スパンの場合、隣のセルをマーク
                        if (detection.colspan === 2 && detection.col % 4 < 3) {
                            gridData[index + 1] = {
                                ...gridEntry,
                                isSpanContinuation: true
                            };
                        }
                    });

                    updateGridVisualization();
                    generateAdvancedCode();
                    showStatus('高精度解析が完了しました！', 'success');
                    analyzeButton.disabled = false;
                };

                img.src = currentImage;

            } catch (error) {
                showStatus(`解析中にエラーが発生しました: ${error.message}`, 'error');
                analyzeButton.disabled = false;
            }
        }

        // グリッド可視化の更新（変更なし）
        function updateGridVisualization() {
            const cells = gridVisualization.querySelectorAll('.grid-cell');

            cells.forEach((cell, index) => {
                const data = gridData[index];
                cell.classList.remove('detected', 'logo-span', 'span-continuation');

                if (data) {
                    cell.classList.add('detected');

                    if (data.isSpanContinuation) {
                        cell.classList.add('span-continuation');
                        cell.textContent = '← スパン続き';
                    } else {
                        if (data.colspan > 1) {
                            cell.classList.add('logo-span');
                            cell.textContent = `${data.originalText || data.type} (${data.colspan}列)`;
                        } else {
                            cell.textContent = data.originalText || data.type;
                        }

                        if (data.confidence) {
                            cell.title = `信頼度: ${Math.round(data.confidence * 100)}%`;
                        }
                    }
                } else {
                    cell.textContent = `${index + 1}`;
                    cell.title = '';
                }
            });
        }

        // 高精度CSSグリッドコード生成（変更なし）
        function generateAdvancedCode() {
            let html = '';
            let css = `/* CSS Grid Layout - 高精度解析結果 */
.grid-container {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(4, 1fr);
    gap: 20px;
    padding: 20px;
    min-height: 100vh;
    background: linear-gradient(135deg, #8B4513 0%, #D2691E 100%);
}

`;

            const processedIndices = new Set();

            gridData.forEach((data, index) => {
                if (data && !processedIndices.has(index) && !data.isSpanContinuation) {
                    const row = Math.floor(index / 4) + 1;
                    const col = (index % 4) + 1;

                    let content = '';
                    let className = `grid-item-${index + 1}`;
                    let gridColumnSpan = data.colspan || 1;

                    switch (data.type) {
                        case 'logo-center':
                            content = `<div class="logo-container logo-center">
    <img src="logo-center.png" alt="Company Logo (Center)" class="logo-image">
</div>`;
                            break;
                        case 'logo-left':
                            content = `<div class="logo-container logo-left">
    <img src="logo-left.png" alt="Company Logo (Left)" class="logo-image">
</div>`;
                            break;
                        case 'sns':
                            content = `<div class="sns-container">
    <a href="#" class="sns-icon facebook" aria-label="Facebook">
        <i class="fab fa-facebook-f"></i>
    </a>
    <a href="#" class="sns-icon twitter" aria-label="Twitter">
        <i class="fab fa-x-twitter"></i>
    </a>
    <a href="#" class="sns-icon instagram" aria-label="Instagram">
        <i class="fab fa-instagram"></i>
    </a>
</div>`;
                            break;
                        case 'home':
                            content = `<a href="/" class="nav-link home">Home</a>`;
                            break;
                        case 'terms':
                            content = `<a href="/terms" class="nav-link terms">利用規約</a>`;
                            break;
                        case 'sitemap':
                            content = `<a href="/sitemap" class="nav-link sitemap">サイトマップ</a>`;
                            break;
                        case 'privacy':
                            content = `<a href="/privacy" class="nav-link privacy">プライバシーポリシー</a>`;
                            break;
                        case 'content_group':
                            content = `<div class="section-header">
    <h3>コンテンツ</h3>
</div>`;
                            break;
                        case 'support_group':
                            content = `<div class="section-header">
    <h3>サポート</h3>
</div>`;
                            break;
                        case 'policy_group':
                            content = `<div class="section-header">
    <h3>ポリシー</h3>
</div>`;
                            break;
                        case 'nav_link': // その他ナビゲーション要素
                            content = `<a href="#" class="nav-link">${data.originalText}</a>`;
                            break;
                        case 'phone':
                            content = `<div class="contact-info">
    <a href="tel:042-637-8111" class="phone-link">
        <i class="fas fa-phone"></i> TEL. 042-637-8111
    </a>
</div>`;
                            break;
                        case 'copyright':
                            content = `<div class="copyright">
    <small>&copy; 2025 Logo</small>
</div>`;
                            break;
                        default:
                            content = `<div class="custom-content">${data.originalText}</div>`;
                    }

                    html += `    <div class="${className}">\n        ${content}\n    </div>\n`;

                    // CSS生成
                    css += `.${className} {
    grid-column: ${col}${gridColumnSpan > 1 ? ` / span ${gridColumnSpan}` : ''};
    grid-row: ${row};
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
}

`;

                    // 処理済みインデックスをマーク
                    processedIndices.add(index);
                    if (gridColumnSpan > 1) {
                        for (let i = 1; i < gridColumnSpan; i++) {
                            processedIndices.add(index + i);
                        }
                    }
                }
            });

            // 追加のスタイリング
            css += `
/* 追加スタイル */
.logo-container {
    width: 100%;
}

.logo-image {
    max-width: 100%;
    height: auto;
    filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
}

.logo-center {
    text-align: center;
}

.logo-left {
    text-align: left;
}

.section-header {
    width: 100%;
    text-align: center;
    border-bottom: 2px solid #333;
    padding-bottom: 5px;
}

.section-header h3 {
    margin: 0;
    font-size: 1.1em;
    font-weight: bold;
    color: #333;
}

.sns-container {
    display: flex;
    gap: 15px;
    align-items: center;
}

.sns-icon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: #333;
    color: white;
    text-decoration: none;
    transition: transform 0.3s ease;
}

.sns-icon:hover {
    transform: scale(1.1);
}

.nav-link {
    color: #333;
    text-decoration: none;
    font-weight: 500;
    padding: 10px 20px;
    border-radius: 5px;
    transition: background-color 0.3s ease;
    display: block;
    width: 100%;
    text-align: center;
}

.nav-link:hover {
    background-color: rgba(255,255,255,0.2);
    transform: translateY(-1px);
}

.contact-info {
    color: #333;
}

.phone-link {
    color: #333;
    text-decoration: none;
    font-weight: 500;
}

.phone-link:hover {
    color: #555;
}

.copyright {
    color: #666;
    font-size: 0.9em;
    text-align: center;
}

.custom-content {
    color: #333;
    font-weight: 500;
}
`;

            const fullCode = `<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generated Grid Layout - Enhanced</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
${css}
    </style>
</head>
<body>
    <div class="grid-container">
${html}    </div>
</body>
</html>`;

            codeOutput.textContent = fullCode;
            codeContainer.style.display = 'block';
        }

        // イベントリスナー
        imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleFile(file);
            }
        });

        // カメラ関連のイベントリスナー
        cameraButton.addEventListener('click', startCamera);
        captureButton.addEventListener('click', capturePhoto);
        stopCameraButton.addEventListener('click', stopCamera);

        // ドラッグ&ドロップ
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) {
                handleFile(file);
            }
        });

        analyzeButton.addEventListener('click', analyzeImageContent);

        // 初期化
        initializeGrid();
    </script>
</body>

</html>