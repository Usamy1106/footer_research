<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4x4 Grid Image Analyzer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s ease;
            background: #f8f9ff;
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: #f0f2ff;
        }

        .upload-area.dragover {
            border-color: #764ba2;
            background: #e8ecff;
        }

        input[type="file"] {
            margin: 20px 0;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
        }

        .preview-container {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
        }

        .image-preview,
        .grid-preview {
            flex: 1;
        }

        .image-preview img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }

        .grid-visualization {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            border: 2px solid #333;
            padding: 20px;
            background: #f9f9f9;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .grid-cell {
            aspect-ratio: 1;
            border: 2px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            text-align: center;
            background: white;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .grid-cell.logo-span {
            background: #e3f2fd;
            border-color: #1976d2;
            font-weight: bold;
            position: relative;
        }

        .grid-cell.span-continuation {
            background: #e8f5e8;
            border-color: #4caf50;
            font-size: 10px;
            opacity: 0.7;
        }

        .code-output {
            background: #1e1e1e;
            color: #fff;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .analyze-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: block;
            margin: 0 auto;
        }

        .analyze-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .camera-button,
        .capture-button,
        .stop-camera-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            margin: 10px 5px;
            transition: all 0.3s ease;
        }

        .camera-button:hover,
        .capture-button:hover,
        .stop-camera-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        #cameraContainer {
            margin-top: 20px;
            text-align: center;
        }

        #cameraVideo {
            border: 3px solid #667eea;
            border-radius: 10px;
            object-fit: cover;
        }

        .camera-controls {
            margin-top: 15px;
        }

        .status {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-weight: bold;
        }

        .status.success {
            background: #e8f5e8;
            color: #2e7d32;
            border: 2px solid #4caf50;
        }

        .status.error {
            background: #fce8e6;
            color: #c62828;
            border: 2px solid #f44336;
        }

        .status.info {
            background: #e3f2fd;
            color: #1565c0;
            border: 2px solid #2196f3;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ğŸ¯ 4x4 Grid Image Analyzer</h1>

        <div class="upload-area" id="uploadArea">
            <h3>ğŸ“ ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ ã¾ãŸã¯ ğŸ“· ã‚«ãƒ¡ãƒ©ã§æ’®å½±</h3>
            <p>4x4ã‚°ãƒªãƒƒãƒ‰ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®ç”»åƒã‚’ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã€é¸æŠã€ã¾ãŸã¯ã‚«ãƒ¡ãƒ©ã§æ’®å½±ã—ã¦ãã ã•ã„</p>
            <input type="file" id="imageInput" accept="image/*,.heic,.heif">
            <button class="camera-button" id="cameraButton">ğŸ“· ã‚«ãƒ¡ãƒ©ã‚’èµ·å‹•</button>

            <div id="cameraContainer" style="display: none;">
                <video id="cameraVideo" width="400" height="400" autoplay></video>
                <canvas id="cameraCanvas" width="400" height="400" style="display: none;"></canvas>
                <div class="camera-controls">
                    <button class="capture-button" id="captureButton">ğŸ“¸ æ’®å½±</button>
                    <button class="stop-camera-button" id="stopCameraButton">âŒ ã‚«ãƒ¡ãƒ©åœæ­¢</button>
                </div>
            </div>
        </div>

        <div id="status" class="status" style="display: none;"></div>

        <div class="preview-container" id="previewContainer" style="display: none;">
            <div class="image-preview">
                <h3>ğŸ“· ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç”»åƒ</h3>
                <img id="uploadedImage" alt="Uploaded image">
            </div>
            <div class="grid-preview">
                <h3>ğŸ¯ æ¤œå‡ºçµæœ</h3>
                <div class="grid-visualization" id="gridVisualization"></div>
                <button class="analyze-button" id="analyzeButton">ğŸ” ç”»åƒã‚’è§£æ</button>
            </div>
        </div>

        <div id="codeContainer" style="display: none;">
            <h3>ğŸ’» ç”Ÿæˆã•ã‚ŒãŸCSSã‚°ãƒªãƒƒãƒ‰ã‚³ãƒ¼ãƒ‰</h3>
            <div class="code-output" id="codeOutput"></div>
        </div>
    </div>

    <script>
        // ç”»åƒèªè­˜ç”¨ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°è¾æ›¸
        const contentPatterns = {
            'logo-center': ['logo', 'ãƒ­ã‚´', 'LOGO'],
            'logo-left': ['logo', 'ãƒ­ã‚´', 'LOGO'],
            'sns': ['facebook', 'twitter', 'instagram', 'x', 'sns', 'SNS', 'f', 'ig'],
            'home': ['home', 'ãƒ›ãƒ¼ãƒ ', 'HOME'],
            'terms': ['åˆ©ç”¨è¦ç´„', 'è¦ç´„', 'terms'],
            'sitemap': ['ã‚µã‚¤ãƒˆãƒãƒƒãƒ—', 'sitemap', 'SITEMAP'],
            'privacy': ['ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ãƒãƒªã‚·ãƒ¼', 'privacy', 'ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼', 'ãƒãƒªã‚·ãƒ¼'],
            'phone': ['tel', 'TEL', '042', '637', '8111', 'é›»è©±'],
            'copyright': ['Â©', 'copyright', '2025', 'Â©2025'],
            'content_group': ['ã‚³ãƒ³ãƒ†ãƒ³ãƒ„', 'content'],
            'support_group': ['ã‚µãƒãƒ¼ãƒˆ', 'support'],
            'policy_group': ['ãƒãƒªã‚·ãƒ¼', 'policy'],
            // ç°¡ç•¥åŒ–ã®ãŸã‚ã€ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³è¦ç´ ã¯åˆ†é¡ã—ãªã„
        };

        // ã‚«ãƒ¡ãƒ©é–¢é€£ã®å¤‰æ•°
        let cameraStream = null;
        let cameraVideo = null;
        let cameraCanvas = null;
        let cameraContext = null;

        // DOMè¦ç´ ã®å–å¾—
        const uploadArea = document.getElementById('uploadArea');
        const imageInput = document.getElementById('imageInput');
        const uploadedImage = document.getElementById('uploadedImage');
        const previewContainer = document.getElementById('previewContainer');
        const gridVisualization = document.getElementById('gridVisualization');
        const analyzeButton = document.getElementById('analyzeButton');
        const codeContainer = document.getElementById('codeContainer');
        const codeOutput = document.getElementById('codeOutput');
        const status = document.getElementById('status');
        const cameraButton = document.getElementById('cameraButton');
        const cameraContainer = document.getElementById('cameraContainer');
        const cameraVideoElement = document.getElementById('cameraVideo');
        const captureButton = document.getElementById('captureButton');
        const stopCameraButton = document.getElementById('stopCameraButton');
        const cameraCanvasElement = document.getElementById('cameraCanvas');

        // ã‚°ãƒªãƒƒãƒ‰ã®çŠ¶æ…‹ã‚’ä¿å­˜
        let gridData = Array(16).fill(null);
        let currentImage = null;

        // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºé–¢æ•°
        function showStatus(message, type = 'info') {
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';

            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    status.style.display = 'none';
                }, 3000);
            }
        }

        // ã‚°ãƒªãƒƒãƒ‰å¯è¦–åŒ–ã®åˆæœŸåŒ–
        function initializeGrid() {
            gridVisualization.innerHTML = '';
            for (let i = 0; i < 16; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.textContent = `${i + 1}`;
                cell.dataset.index = i;
                gridVisualization.appendChild(cell);
            }
        }

        // --- â˜… HEICå¯¾å¿œãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®èª­ã¿è¾¼ã¿ï¼ˆlibheif-jsã«å†åˆ‡ã‚Šæ›¿ãˆï¼‰â˜… ---
        async function loadHeifLibrary() {
            return new Promise((resolve, reject) => {
                if (window.HeifImage) {
                    resolve(window.HeifImage);
                    return;
                }

                const script = document.createElement('script');
                // libheif-js ã®CDNã‚’ä½¿ç”¨
                script.src = 'https://cdn.jsdelivr.net/npm/libheif-js@1.17.1/libheif-bundle.min.js';
                script.onload = () => {
                    if (window.HeifImage) {
                        resolve(window.HeifImage);
                    } else {
                        reject(new Error('HEICãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚'));
                    }
                };
                script.onerror = (error) => {
                    console.error('HEICãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                    reject(new Error('HEICãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚'));
                };
                document.head.appendChild(script);
            });
        }

        // --- â˜… ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å‡¦ç†ï¼ˆHEICå¯¾å¿œä¿®æ­£ç‰ˆ - libheif-jsã‚’ä½¿ç”¨ï¼‰â˜… ---
        async function handleFile(file) {
            if (!file.type.startsWith('image/') &&
                !file.name.toLowerCase().endsWith('.heic') &&
                !file.name.toLowerCase().endsWith('.heif')) {
                showStatus('å¯¾å¿œã—ã¦ã„ãªã„ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™ã€‚ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯HEICãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚', 'error');
                return;
            }

            let processedFile = file;
            let isHeic = file.name.toLowerCase().endsWith('.heic') || file.name.toLowerCase().endsWith('.heif');

            // HEIC/HEIFå½¢å¼ã®å¤‰æ›
            if (isHeic) {
                try {
                    showStatus('HEICå¤‰æ›ç”¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’èª­ã¿è¾¼ã¿ä¸­...', 'info');
                    const HeifImage = await loadHeifLibrary();

                    showStatus('HEICç”»åƒã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ä¸­...', 'info');
                    const buffer = await file.arrayBuffer();

                    const decoder = new HeifImage.HeifDecoder();
                    const images = decoder.decode(buffer);

                    if (images.length === 0) {
                        throw new Error("HEICãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ç”»åƒã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚");
                    }

                    // æœ€åˆã®ç”»åƒã‚’Canvasã«æç”»ã—ã¦JPEG Blobã«å¤‰æ›
                    const image = images[0];
                    const canvas = document.createElement('canvas');
                    canvas.width = image.get_width();
                    canvas.height = image.get_height();
                    const ctx = canvas.getContext('2d');

                    const imageData = ctx.createImageData(canvas.width, canvas.height);
                    imageData.data.set(new Uint8ClampedArray(image.get_data()));
                    ctx.putImageData(imageData, 0, 0);

                    processedFile = await new Promise(resolve => {
                        canvas.toBlob(resolve, 'image/jpeg', 0.9);
                    });

                    showStatus('HEICå¤‰æ›å®Œäº†ã€‚ç”»åƒã‚’èª­ã¿è¾¼ã¿ä¸­...', 'success');
                } catch (error) {
                    console.error('HEICå¤‰æ›ã‚¨ãƒ©ãƒ¼:', error);
                    showStatus(`HEICå¤‰æ›ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message ? error.message : 'ãƒ•ã‚¡ã‚¤ãƒ«è§£æã‚¨ãƒ©ãƒ¼'}ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ãŒç ´æã—ã¦ã„ã‚‹ã‹ã€æœªå¯¾å¿œã®HEICå½¢å¼ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚`, 'error');
                    return;
                }
            }

            const reader = new FileReader();
            reader.onload = function (e) {
                currentImage = e.target.result;
                uploadedImage.src = currentImage;
                previewContainer.style.display = 'block';
                initializeGrid();
                showStatus('ç”»åƒãŒèª­ã¿è¾¼ã¾ã‚Œã¾ã—ãŸã€‚è§£æãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚', 'success');
            };
            reader.onerror = function () {
                showStatus('ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚', 'error');
            };
            reader.readAsDataURL(processedFile);
        }

        // ã‚«ãƒ¡ãƒ©èµ·å‹•
        async function startCamera() {
            try {
                showStatus('ã‚«ãƒ¡ãƒ©ã‚’èµ·å‹•ä¸­...', 'info');
                cameraStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: {
                            ideal: 400
                        },
                        height: {
                            ideal: 400
                        },
                        aspectRatio: 1.0,
                        facingMode: 'environment' // èƒŒé¢ã‚«ãƒ¡ãƒ©ã‚’å„ªå…ˆ
                    }
                });

                cameraVideo = cameraVideoElement;
                cameraCanvas = cameraCanvasElement;
                cameraContext = cameraCanvas.getContext('2d');

                cameraVideo.srcObject = cameraStream;
                cameraContainer.style.display = 'block';
                cameraButton.style.display = 'none';

                showStatus('ã‚«ãƒ¡ãƒ©ãŒèµ·å‹•ã—ã¾ã—ãŸã€‚æ’®å½±ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚', 'success');
            } catch (error) {
                console.error('Camera error:', error);
                showStatus('ã‚«ãƒ¡ãƒ©ã®èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚', 'error');
            }
        }

        // å†™çœŸæ’®å½±
        function capturePhoto() {
            if (!cameraStream) return;

            cameraContext.drawImage(cameraVideo, 0, 0, 400, 400);
            cameraCanvas.toBlob(function (blob) {
                const file = new File([blob], 'camera-capture.jpg', {
                    type: 'image/jpeg'
                });
                handleFile(file);
                stopCamera();
            }, 'image/jpeg', 0.9);
        }

        // ã‚«ãƒ¡ãƒ©åœæ­¢
        function stopCamera() {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }
            cameraContainer.style.display = 'none';
            cameraButton.style.display = 'inline-block';
            showStatus('ã‚«ãƒ¡ãƒ©ã‚’åœæ­¢ã—ã¾ã—ãŸã€‚', 'info');
        }

        // 2æ®µéšç”»åƒè§£æï¼šä½™ç™½æ¤œå‡º â†’ ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ¤œå‡º
        function simulateAdvancedTextDetection(canvas) {
            return new Promise((resolve) => {
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                setTimeout(() => {
                    console.log('Phase 1: ä½™ç™½æ¤œå‡ºã‚’é–‹å§‹...');

                    // Phase 1: ä½™ç™½é ˜åŸŸã‚’ç‰¹å®š
                    const emptyAreas = detectEmptyAreas(imageData, canvas.width, canvas.height);

                    console.log('Phase 2: ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ¤œå‡ºã‚’é–‹å§‹...');

                    // Phase 2: ä½™ç™½ä»¥å¤–ã®é ˜åŸŸã§ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’æ¤œå‡º
                    const contentAreas = detectContentAreas(imageData, canvas.width, canvas.height, emptyAreas);

                    console.log(`æ¤œå‡ºå®Œäº†: ${contentAreas.length}å€‹ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„å€™è£œã‚’ç™ºè¦‹`);

                    resolve(contentAreas); // ç”Ÿã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„å€™è£œã‚’è¿”ã™
                }, 1500);
            });
        }

        // Phase 1: ä½™ç™½é ˜åŸŸã®æ¤œå‡ºï¼ˆå¤‰æ›´ãªã—ï¼‰
        function detectEmptyAreas(imageData, width, height) {
            const data = imageData.data;
            const emptyGrids = new Set();

            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    const cellKey = `${row}-${col}`;

                    if (row === 3) continue; // æœ€ä¸‹æ®µã¯ã‚¹ã‚­ãƒƒãƒ—

                    const isEmpty = analyzeCellForEmptiness(data, width, height, row, col);

                    if (isEmpty.confidence > 0.85) {
                        emptyGrids.add(cellKey);
                    }
                }
            }
            return emptyGrids;
        }

        // ã‚»ãƒ«ã®ä½™ç™½åˆ¤å®šï¼ˆå¤‰æ›´ãªã—ï¼‰
        function analyzeCellForEmptiness(data, width, height, row, col) {
            const cellWidth = Math.floor(width / 4);
            const cellHeight = Math.floor(height / 4);
            const startX = col * cellWidth;
            const startY = row * cellHeight;
            const endX = Math.min(startX + cellWidth, width);
            const endY = Math.min(startY + cellHeight, height);

            let backgroundPixels = 0;
            let contentPixels = 0;
            let totalPixels = 0;
            const colorCounts = new Map();
            const brightnessValues = [];

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const i = (y * width + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const brightness = (r + g + b) / 3;

                    totalPixels++;
                    brightnessValues.push(brightness);

                    if (isLikelyBackground(r, g, b)) {
                        backgroundPixels++;
                    } else {
                        contentPixels++;
                    }

                    const colorKey = `${Math.floor(r / 15)}-${Math.floor(g / 15)}-${Math.floor(b / 15)}`;
                    colorCounts.set(colorKey, (colorCounts.get(colorKey) || 0) + 1);
                }
            }

            const backgroundRatio = backgroundPixels / totalPixels;
            const contentRatio = contentPixels / totalPixels;
            const avgBrightness = brightnessValues.reduce((a, b) => a + b, 0) / brightnessValues.length;
            const brightnessVariance = brightnessValues.reduce((acc, val) => acc + Math.pow(val - avgBrightness, 2), 0) / brightnessValues.length;
            const brightnessStdDev = Math.sqrt(brightnessVariance);
            const uniqueColors = colorCounts.size;
            const maxExpectedColors = Math.max(totalPixels / 100, 10);
            const colorUniformity = Math.max(0, 1 - (uniqueColors / maxExpectedColors));
            const brightnessUniformity = Math.max(0, 1 - (brightnessStdDev / 80));

            const emptyConfidence = (
                backgroundRatio * 0.6 +
                colorUniformity * 0.25 +
                brightnessUniformity * 0.15
            ) - (contentRatio * 0.2);

            return {
                confidence: Math.max(0, Math.min(emptyConfidence, 1.0)),
                backgroundRatio,
                contentRatio,
                colorUniformity,
                brightnessUniformity,
                uniqueColors,
                avgBrightness
            };
        }

        // èƒŒæ™¯è‰²ã®å¯èƒ½æ€§åˆ¤å®šï¼ˆå¤‰æ›´ãªã—ï¼‰
        function isLikelyBackground(r, g, b) {
            const isWhitish = (r > 230 && g > 230 && b > 230);
            const isGrayish = (
                Math.abs(r - g) < 25 && Math.abs(g - b) < 25 &&
                r > 180 && g > 180 && b > 180
            );
            const isWoodish = (
                r >= 120 && r <= 220 &&
                g >= 100 && g <= 190 &&
                b >= 80 && b <= 160 &&
                (r - g) > -20 && (r - g) < 50 &&
                (g - b) > -10 && (g - b) < 60
            );
            const isBeigeish = (
                r >= 200 && r <= 255 &&
                g >= 190 && g <= 240 &&
                b >= 170 && b <= 220 &&
                Math.abs(r - g) < 30 && Math.abs(g - b) < 30
            );

            return isWhitish || isGrayish || isWoodish || isBeigeish;
        }

        // Phase 2: ã‚³ãƒ³ãƒ†ãƒ³ãƒ„é ˜åŸŸã®æ¤œå‡ºï¼ˆãƒ­ã‚¸ãƒƒã‚¯ã‚’ã‚ˆã‚Šå³å¯†ã«ï¼‰
        function detectContentAreas(imageData, width, height, emptyAreas) {
            const data = imageData.data;
            const contentAreas = [];

            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    const cellKey = `${row}-${col}`;

                    if (emptyAreas.has(cellKey)) {
                        continue;
                    }

                    const contentAnalysis = analyzeContentInCell(data, width, height, row, col);

                    // æ¤œå‡ºä¿¡é ¼åº¦ã‚’0.3ä»¥ä¸Šã«å³ã—ãè¨­å®š
                    if (contentAnalysis.hasContent && contentAnalysis.confidence > 0.3) {
                        contentAreas.push({
                            row,
                            col,
                            position: {
                                x: (col + 0.5) / 4,
                                y: (row + 0.5) / 4
                            },
                            ...contentAnalysis
                        });
                    }
                }
            }
            return contentAreas;
        }

        // ã‚»ãƒ«å†…ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„åˆ†æï¼ˆãƒ­ã‚´ãƒ»ãƒ†ã‚­ã‚¹ãƒˆã®æ¤œå‡ºåŸºæº–ã‚’å³å¯†åŒ–ï¼‰
        function analyzeContentInCell(data, width, height, row, col) {
            const cellWidth = Math.floor(width / 4);
            const cellHeight = Math.floor(height / 4);
            const startX = col * cellWidth;
            const startY = row * cellHeight;
            const endX = Math.min(startX + cellWidth, width);
            const endY = Math.min(startY + cellHeight, height);

            let darkPixels = 0;
            let edgePixels = 0;
            let textLikeRegions = 0;
            let logoLikeRegions = 0;
            let nonBackgroundPixels = 0;
            const totalPixels = (endX - startX) * (endY - startY);

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const i = (y * width + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const brightness = (r + g + b) / 3;

                    if (!isLikelyBackground(r, g, b)) {
                        nonBackgroundPixels++;

                        if (brightness < 160) { // åŸºæº–ã‚’180â†’160ã«å³ã—ã
                            darkPixels++;

                            if (hasLogoLikePattern(data, width, x, y)) {
                                logoLikeRegions++;
                            }

                            if (hasTextLikePattern(data, width, x, y)) {
                                textLikeRegions++;
                            }
                        }
                    }

                    if (detectMediumEdge(data, width, x, y)) {
                        edgePixels++;
                    }
                }
            }

            const darkRatio = darkPixels / totalPixels;
            const edgeRatio = edgePixels / totalPixels;
            const textRatio = textLikeRegions / totalPixels;
            const logoRatio = logoLikeRegions / totalPixels;
            const nonBgRatio = nonBackgroundPixels / totalPixels;

            let contentType = 'unknown';
            let hasContent = false;
            let confidence = 0;

            if (nonBgRatio > 0.05) { // èƒŒæ™¯ã§ãªã„ç”»ç´ ãŒ5%ä»¥ä¸Šï¼ˆå³ã—ãï¼‰
                hasContent = true;

                // ãƒ­ã‚´åˆ¤å®š: ä¸Šæ®µã§å¡ŠçŠ¶ã®æ¿ƒã„é ˜åŸŸãŒå¤šã„
                if ((row === 0 || row === 1) && logoRatio > 0.015) { // é–¾å€¤ã‚’ä¸Šã’ã‚‹
                    contentType = 'logo';
                    confidence = Math.min((logoRatio * 30) + (darkRatio * 10), 1.0);
                }
                // ãƒ†ã‚­ã‚¹ãƒˆåˆ¤å®š: ã‚¨ãƒƒã‚¸ã¨ãƒ†ã‚­ã‚¹ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³ãŒå¤šã„
                else if (textRatio > 0.01 || edgeRatio > 0.03) {
                    contentType = 'text';
                    confidence = Math.min((textRatio * 40) + (edgeRatio * 15) + (darkRatio * 5), 1.0);
                }
                // ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯åˆ¤å®š: å›³å½¢çš„ãªè¦ç´ ãŒå¤šã„
                else if (edgeRatio > 0.02) {
                    contentType = 'graphic';
                    confidence = Math.min((edgeRatio * 15) + (darkRatio * 8), 1.0);
                }
                // ãã®ä»–
                else {
                    contentType = 'mixed';
                    confidence = Math.min(nonBgRatio * 8, 1.0);
                }

                // ä¿¡é ¼åº¦ã‚’æœ€ä½ä¿è¨¼
                confidence = Math.max(confidence, nonBgRatio * 5);
            }

            // æœ€çµ‚ãƒã‚§ãƒƒã‚¯ï¼šä¿¡é ¼åº¦ãŒ0.3æœªæº€ãªã‚‰ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¨è¦‹ãªã•ãªã„
            if (confidence < 0.3) {
                hasContent = false;
            }

            return {
                hasContent,
                confidence,
                contentType,
                darkRatio,
                edgeRatio,
                textRatio,
                logoRatio,
                nonBgRatio
            };
        }

        // ä¸­ç¨‹åº¦ã®ã‚¨ãƒƒã‚¸æ¤œå‡ºï¼ˆå¤‰æ›´ãªã—ï¼‰
        function detectMediumEdge(data, width, x, y) {
            if (x <= 0 || x >= width - 1 || y <= 0) return false;

            const current = (y * width + x) * 4;
            const right = (y * width + (x + 1)) * 4;
            const down = ((y + 1) * width + x) * 4;

            const currentBrightness = (data[current] + data[current + 1] + data[current + 2]) / 3;
            const rightBrightness = (data[right] + data[right + 1] + data[right + 2]) / 3;
            const downBrightness = (data[down] + data[down + 1] + data[down + 2]) / 3;

            const horizontalDiff = Math.abs(currentBrightness - rightBrightness);
            const verticalDiff = Math.abs(currentBrightness - downBrightness);

            return horizontalDiff > 40 || verticalDiff > 40;
        }

        // ãƒ­ã‚´ã£ã½ã„ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œå‡ºï¼ˆå¤‰æ›´ãªã—ï¼‰
        function hasLogoLikePattern(data, width, x, y) {
            const centerI = (y * width + x) * 4;
            const centerBrightness = (data[centerI] + data[centerI + 1] + data[centerI + 2]) / 3;

            if (centerBrightness > 120) return false;

            let similarDarkPixels = 0;
            const radius = 3;

            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < width && ny >= 0) {
                        const ni = (ny * width + nx) * 4;
                        const neighborBrightness = (data[ni] + data[ni + 1] + data[ni + 2]) / 3;

                        if (Math.abs(centerBrightness - neighborBrightness) < 40 && neighborBrightness < 150) {
                            similarDarkPixels++;
                        }
                    }
                }
            }

            return similarDarkPixels >= 12;
        }

        // ãƒ†ã‚­ã‚¹ãƒˆã£ã½ã„ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œå‡ºï¼ˆå¤‰æ›´ãªã—ï¼‰
        function hasTextLikePattern(data, width, x, y) {
            const centerI = (y * width + x) * 4;
            const centerBrightness = (data[centerI] + data[centerI + 1] + data[centerI + 2]) / 3;

            let contrastCount = 0;
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [1, 1], [-1, 1], [1, -1]];

            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                const ni = (ny * width + nx) * 4;
                const neighborBrightness = (data[ni] + data[ni + 1] + data[ni + 2]) / 3;

                if (Math.abs(centerBrightness - neighborBrightness) > 60) {
                    contrastCount++;
                }
            }

            return contrastCount >= 3;
        }


        // --- â˜… æ–°ã—ã„å¾Œå‡¦ç†ï¼šæ¤œå‡ºçµæœã®çµåˆã¨æœ€çµ‚åˆ†é¡ï¼ˆä½ç½®ã«ã‚ˆã‚‹æ±ºã‚æ‰“ã¡ã‚’æ’é™¤ï¼‰â˜… ---
        function postProcessDetections(contentAreas) {
            const processedDetections = [];
            const occupiedCells = new Set();
            // ã‚°ãƒªãƒƒãƒ‰ã‚’åˆæœŸåŒ–ã—ã€æ¤œå‡ºã•ã‚ŒãŸã‚³ãƒ³ãƒ†ãƒ³ãƒ„å€™è£œã‚’é…ç½®
            const grid = contentAreas.reduce((acc, det) => {
                const index = det.row * 4 + det.col;
                acc[index] = { ...det, colspan: 1 };
                return acc;
            }, Array(16).fill(null));


            // 1. éš£æ¥ã™ã‚‹ã‚³ãƒ³ãƒ†ãƒ³ãƒ„å€™è£œã®çµåˆ
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    const index = row * 4 + col;
                    const det = grid[index];

                    if (!det || occupiedCells.has(index)) continue;

                    let currentColspan = 1;

                    // ãƒ­ã‚´å€™è£œï¼ˆä¸Š2æ®µã«ã‚ã‚‹ï¼‰ã‹ã¤éš£ã®ã‚»ãƒ«ãŒã‚ã‚‹å ´åˆ
                    if ((row === 0 || row === 1) && det.contentType === 'logo' && col <= 2) {
                        const neighborIndex = index + 1;
                        const neighbor = grid[neighborIndex];

                        // éš£ã®ã‚»ãƒ«ã‚‚ãƒ­ã‚´å€™è£œã§ã‚ã‚Œã°çµåˆ
                        if (neighbor && neighbor.contentType === 'logo' && !occupiedCells.has(neighborIndex)) {
                            currentColspan = 2;
                            occupiedCells.add(neighborIndex);
                        }
                    }

                    det.colspan = currentColspan;
                    occupiedCells.add(index);
                    processedDetections.push(det);
                }
            }

            // 2. çµåˆå¾Œã®æœ€çµ‚åˆ†é¡ï¼ˆã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¤ãƒ—ã¯ä½ç½®ã«ç´ã¥ãä¸€èˆ¬çš„ãªãƒ•ãƒƒã‚¿ãƒ¼è¦ç´ ã«åˆ†é¡ï¼‰
            processedDetections.forEach(det => {
                // ãƒ­ã‚´è¦ç´ ã®æ±ºå®š
                if (det.contentType === 'logo') {
                    det.text = det.colspan === 2 ? 'Logo (2 Columns)' : 'Logo (Single)';
                    det.contentType = det.colspan === 2 ? 'logo-center' : 'logo-left';
                    return;
                }

                // 2æ®µç›®ï¼ˆã‚µãƒ¼ãƒ“ã‚¹/ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼‰
                if (det.row === 1) {
                    const groupMap = ['ã‚³ãƒ³ãƒ†ãƒ³ãƒ„', 'ã‚µãƒãƒ¼ãƒˆ', 'ãƒãƒªã‚·ãƒ¼', 'ãƒŠãƒ“'];
                    const typeMap = ['content_group', 'support_group', 'policy_group', 'nav_link'];
                    det.text = groupMap[det.col] || 'Nav Link';
                    det.contentType = typeMap[det.col] || 'nav_link';
                    return;
                }

                // 3æ®µç›®ï¼ˆä¸»è¦ãƒªãƒ³ã‚¯ï¼‰
                if (det.row === 2) {
                    const footerMap = ['Home', 'ã‚µã‚¤ãƒˆãƒãƒƒãƒ—', 'ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ãƒãƒªã‚·ãƒ¼', 'åˆ©ç”¨è¦ç´„'];
                    const typeMap = ['home', 'sitemap', 'privacy', 'terms'];
                    det.text = footerMap[det.col] || 'Nav Link';
                    det.contentType = typeMap[det.col] || 'nav_link';
                    return;
                }

                // 4æ®µç›®ï¼ˆãƒœãƒˆãƒ æƒ…å ±ï¼‰
                if (det.row === 3) {
                    if (det.col === 0) {
                        det.text = 'SNS Icons';
                        det.contentType = 'sns';
                    } else if (det.col === 1) {
                        det.text = 'TEL. 042-637-8111';
                        det.contentType = 'phone';
                    } else if (det.col === 2) {
                        det.text = 'Â© 2025 Logo';
                        det.contentType = 'copyright';
                    } else {
                        det.text = 'Custom Info';
                        det.contentType = 'other';
                    }
                    return;
                }

                // ä¸Šæ®µã§ãƒ­ã‚´ã§ã‚‚ãªã„ãƒ†ã‚­ã‚¹ãƒˆè¦ç´ 
                if (det.row === 0 && det.contentType === 'text') {
                    det.text = 'Main Nav Link';
                    det.contentType = 'nav_link';
                    return;
                }

                det.text = 'ä¸æ˜ãªã‚³ãƒ³ãƒ†ãƒ³ãƒ„';
                det.contentType = 'other';
            });

            return processedDetections;
        }

        // ä½ç½®ã‹ã‚‰4x4ã‚°ãƒªãƒƒãƒ‰ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¨ˆç®—ï¼ˆç°¡ç•¥åŒ–ï¼šä½¿ã‚ãªã„ï¼‰
        function getGridIndexAdvanced(x, y, width = 0.25, height = 0.25, text = '') {
            // ã“ã®é–¢æ•°ã¯æ–°ã—ã„ãƒ­ã‚¸ãƒƒã‚¯ã§ã¯ä½¿ç”¨ã—ãªã„ãŒã€äº’æ›æ€§ã®ãŸã‚ã«æ®‹ã™
            const col = Math.floor(x * 4);
            const row = Math.floor(y * 4);
            const baseIndex = Math.min(row * 4 + col, 15);

            return {
                index: baseIndex,
                colspan: 1,
                rowspan: 1,
                type: 'single'
            };
        }

        // ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®šï¼ˆä½¿ç”¨é »åº¦ã¯ä¸‹ãŒã‚‹ãŒæ®‹ã™ï¼‰
        function classifyContent(text) {
            const lowerText = text.toLowerCase();

            for (const [contentType, patterns] of Object.entries(contentPatterns)) {
                for (const pattern of patterns) {
                    if (lowerText.includes(pattern.toLowerCase())) {
                        return contentType;
                    }
                }
            }
            return 'other';
        }

        // å®Ÿéš›ã®ç”»åƒè§£æï¼ˆé«˜ç²¾åº¦ç‰ˆï¼‰
        async function analyzeImageContent() {
            if (!currentImage) {
                showStatus('ç”»åƒãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚', 'error');
                return;
            }

            showStatus('é«˜ç²¾åº¦ç”»åƒè§£æã‚’å®Ÿè¡Œä¸­ï¼ˆç¡¬ç›´ãƒ­ã‚¸ãƒƒã‚¯ä¿®æ­£æ¸ˆã¿ï¼‰...', 'info');
            analyzeButton.disabled = true;

            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();

                img.onload = async () => {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);

                    // 1. ç”»åƒç‰¹å¾´æ¤œå‡ºï¼ˆã‚³ãƒ³ãƒ†ãƒ³ãƒ„å€™è£œãƒªã‚¹ãƒˆã‚’å–å¾—ï¼‰
                    const contentAreas = await simulateAdvancedTextDetection(canvas);

                    // 2. å¾Œå‡¦ç†ã€çµåˆã€æœ€çµ‚åˆ†é¡ï¼ˆæ–°ã—ã„ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
                    const detectedTexts = postProcessDetections(contentAreas);

                    // ã‚°ãƒªãƒƒãƒ‰ãƒ‡ãƒ¼ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆ
                    gridData = Array(16).fill(null);

                    // 3. ã‚°ãƒªãƒƒãƒ‰ã¸ã®åæ˜ 
                    detectedTexts.forEach(detection => {
                        const index = detection.row * 4 + detection.col;

                        const gridEntry = {
                            type: detection.contentType,
                            originalText: detection.text,
                            colspan: detection.colspan,
                            rowspan: 1,
                            confidence: detection.confidence || 0.8
                        };

                        gridData[index] = gridEntry;

                        // 2åˆ—ã‚¹ãƒ‘ãƒ³ã®å ´åˆã€éš£ã®ã‚»ãƒ«ã‚’ãƒãƒ¼ã‚¯
                        if (detection.colspan === 2 && detection.col % 4 < 3) {
                            gridData[index + 1] = {
                                ...gridEntry,
                                isSpanContinuation: true
                            };
                        }
                    });

                    updateGridVisualization();
                    generateAdvancedCode();
                    showStatus('é«˜ç²¾åº¦è§£æãŒå®Œäº†ã—ã¾ã—ãŸï¼', 'success');
                    analyzeButton.disabled = false;
                };

                img.src = currentImage;

            } catch (error) {
                showStatus(`è§£æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`, 'error');
                analyzeButton.disabled = false;
            }
        }

        // ã‚°ãƒªãƒƒãƒ‰å¯è¦–åŒ–ã®æ›´æ–°ï¼ˆå¤‰æ›´ãªã—ï¼‰
        function updateGridVisualization() {
            const cells = gridVisualization.querySelectorAll('.grid-cell');

            cells.forEach((cell, index) => {
                const data = gridData[index];
                cell.classList.remove('detected', 'logo-span', 'span-continuation');

                if (data) {
                    cell.classList.add('detected');

                    if (data.isSpanContinuation) {
                        cell.classList.add('span-continuation');
                        cell.textContent = 'â† ã‚¹ãƒ‘ãƒ³ç¶šã';
                    } else {
                        if (data.colspan > 1) {
                            cell.classList.add('logo-span');
                            cell.textContent = `${data.originalText || data.type} (${data.colspan}åˆ—)`;
                        } else {
                            cell.textContent = data.originalText || data.type;
                        }

                        if (data.confidence) {
                            cell.title = `ä¿¡é ¼åº¦: ${Math.round(data.confidence * 100)}%`;
                        }
                    }
                } else {
                    cell.textContent = `${index + 1}`;
                    cell.title = '';
                }
            });
        }

        // é«˜ç²¾åº¦CSSã‚°ãƒªãƒƒãƒ‰ã‚³ãƒ¼ãƒ‰ç”Ÿæˆï¼ˆå¤‰æ›´ãªã—ï¼‰
        function generateAdvancedCode() {
            let html = '';
            let css = `/* CSS Grid Layout - é«˜ç²¾åº¦è§£æçµæœ */
.grid-container {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(4, 1fr);
    gap: 20px;
    padding: 20px;
    min-height: 100vh;
    background: linear-gradient(135deg, #8B4513 0%, #D2691E 100%);
}

`;

            const processedIndices = new Set();

            gridData.forEach((data, index) => {
                if (data && !processedIndices.has(index) && !data.isSpanContinuation) {
                    const row = Math.floor(index / 4) + 1;
                    const col = (index % 4) + 1;

                    let content = '';
                    let className = `grid-item-${index + 1}`;
                    let gridColumnSpan = data.colspan || 1;

                    switch (data.type) {
                        case 'logo-center':
                            content = `<div class="logo-container logo-center">
    <img src="logo-center.png" alt="Company Logo (Center)" class="logo-image">
</div>`;
                            break;
                        case 'logo-left':
                            content = `<div class="logo-container logo-left">
    <img src="logo-left.png" alt="Company Logo (Left)" class="logo-image">
</div>`;
                            break;
                        case 'sns':
                            content = `<div class="sns-container">
    <a href="#" class="sns-icon facebook" aria-label="Facebook">
        <i class="fab fa-facebook-f"></i>
    </a>
    <a href="#" class="sns-icon twitter" aria-label="Twitter">
        <i class="fab fa-x-twitter"></i>
    </a>
    <a href="#" class="sns-icon instagram" aria-label="Instagram">
        <i class="fab fa-instagram"></i>
    </a>
</div>`;
                            break;
                        case 'home':
                            content = `<a href="/" class="nav-link home">Home</a>`;
                            break;
                        case 'terms':
                            content = `<a href="/terms" class="nav-link terms">åˆ©ç”¨è¦ç´„</a>`;
                            break;
                        case 'sitemap':
                            content = `<a href="/sitemap" class="nav-link sitemap">ã‚µã‚¤ãƒˆãƒãƒƒãƒ—</a>`;
                            break;
                        case 'privacy':
                            content = `<a href="/privacy" class="nav-link privacy">ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ãƒãƒªã‚·ãƒ¼</a>`;
                            break;
                        case 'content_group':
                            content = `<div class="section-header">
    <h3>ã‚³ãƒ³ãƒ†ãƒ³ãƒ„</h3>
</div>`;
                            break;
                        case 'support_group':
                            content = `<div class="section-header">
    <h3>ã‚µãƒãƒ¼ãƒˆ</h3>
</div>`;
                            break;
                        case 'policy_group':
                            content = `<div class="section-header">
    <h3>ãƒãƒªã‚·ãƒ¼</h3>
</div>`;
                            break;
                        case 'nav_link': // ãã®ä»–ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³è¦ç´ 
                            content = `<a href="#" class="nav-link">${data.originalText}</a>`;
                            break;
                        case 'phone':
                            content = `<div class="contact-info">
    <a href="tel:042-637-8111" class="phone-link">
        <i class="fas fa-phone"></i> TEL. 042-637-8111
    </a>
</div>`;
                            break;
                        case 'copyright':
                            content = `<div class="copyright">
    <small>&copy; 2025 Logo</small>
</div>`;
                            break;
                        default:
                            content = `<div class="custom-content">${data.originalText}</div>`;
                    }

                    html += `    <div class="${className}">\n        ${content}\n    </div>\n`;

                    // CSSç”Ÿæˆ
                    css += `.${className} {
    grid-column: ${col}${gridColumnSpan > 1 ? ` / span ${gridColumnSpan}` : ''};
    grid-row: ${row};
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
}

`;

                    // å‡¦ç†æ¸ˆã¿ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ãƒãƒ¼ã‚¯
                    processedIndices.add(index);
                    if (gridColumnSpan > 1) {
                        for (let i = 1; i < gridColumnSpan; i++) {
                            processedIndices.add(index + i);
                        }
                    }
                }
            });

            // è¿½åŠ ã®ã‚¹ã‚¿ã‚¤ãƒªãƒ³ã‚°
            css += `
/* è¿½åŠ ã‚¹ã‚¿ã‚¤ãƒ« */
.logo-container {
    width: 100%;
}

.logo-image {
    max-width: 100%;
    height: auto;
    filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
}

.logo-center {
    text-align: center;
}

.logo-left {
    text-align: left;
}

.section-header {
    width: 100%;
    text-align: center;
    border-bottom: 2px solid #333;
    padding-bottom: 5px;
}

.section-header h3 {
    margin: 0;
    font-size: 1.1em;
    font-weight: bold;
    color: #333;
}

.sns-container {
    display: flex;
    gap: 15px;
    align-items: center;
}

.sns-icon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: #333;
    color: white;
    text-decoration: none;
    transition: transform 0.3s ease;
}

.sns-icon:hover {
    transform: scale(1.1);
}

.nav-link {
    color: #333;
    text-decoration: none;
    font-weight: 500;
    padding: 10px 20px;
    border-radius: 5px;
    transition: background-color 0.3s ease;
    display: block;
    width: 100%;
    text-align: center;
}

.nav-link:hover {
    background-color: rgba(255,255,255,0.2);
    transform: translateY(-1px);
}

.contact-info {
    color: #333;
}

.phone-link {
    color: #333;
    text-decoration: none;
    font-weight: 500;
}

.phone-link:hover {
    color: #555;
}

.copyright {
    color: #666;
    font-size: 0.9em;
    text-align: center;
}

.custom-content {
    color: #333;
    font-weight: 500;
}
`;

            const fullCode = `<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generated Grid Layout - Enhanced</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
${css}
    </style>
</head>
<body>
    <div class="grid-container">
${html}    </div>
</body>
</html>`;

            codeOutput.textContent = fullCode;
            codeContainer.style.display = 'block';
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleFile(file);
            }
        });

        // ã‚«ãƒ¡ãƒ©é–¢é€£ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        cameraButton.addEventListener('click', startCamera);
        captureButton.addEventListener('click', capturePhoto);
        stopCameraButton.addEventListener('click', stopCamera);

        // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) {
                handleFile(file);
            }
        });

        analyzeButton.addEventListener('click', analyzeImageContent);

        // åˆæœŸåŒ–
        initializeGrid();
    </script>
</body>

</html>