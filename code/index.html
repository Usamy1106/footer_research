<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4x4 Grid Image Analyzer</title>
    <style>
        /* ã‚¹ã‚¿ã‚¤ãƒ«ã¯å¤‰æ›´ãªã— */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s ease;
            background: #f8f9ff;
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: #f0f2ff;
        }

        .upload-area.dragover {
            border-color: #764ba2;
            background: #e8ecff;
        }

        input[type="file"] {
            margin: 20px 0;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
        }

        .preview-container {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
        }

        .image-preview,
        .grid-preview {
            flex: 1;
        }

        .image-preview img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }

        .grid-visualization {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            border: 2px solid #333;
            padding: 20px;
            background: #f9f9f9;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .grid-cell {
            aspect-ratio: 1;
            border: 2px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            text-align: center;
            background: white;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .grid-cell.logo-span {
            background: #e3f2fd;
            border-color: #1976d2;
            font-weight: bold;
            position: relative;
        }

        .grid-cell.span-continuation {
            background: #e8f5e8;
            border-color: #4caf50;
            font-size: 10px;
            opacity: 0.7;
        }

        .code-output {
            background: #1e1e1e;
            color: #fff;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .analyze-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: block;
            margin: 0 auto;
        }

        .analyze-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .camera-button,
        .capture-button,
        .stop-camera-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            margin: 10px 5px;
            transition: all 0.3s ease;
        }

        .camera-button:hover,
        .capture-button:hover,
        .stop-camera-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        #cameraContainer {
            margin-top: 20px;
            text-align: center;
        }

        #cameraVideo {
            border: 3px solid #667eea;
            border-radius: 10px;
            object-fit: cover;
        }

        .camera-controls {
            margin-top: 15px;
        }

        .status {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-weight: bold;
        }

        .status.success {
            background: #e8f5e8;
            color: #2e7d32;
            border: 2px solid #4caf50;
        }

        .status.error {
            background: #fce8e6;
            color: #c62828;
            border: 2px solid #f44336;
        }

        .status.info {
            background: #e3f2fd;
            color: #1565c0;
            border: 2px solid #2196f3;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ğŸ¯ 4x4 Grid Image Analyzer</h1>

        <div class="upload-area" id="uploadArea">
            <h3>ğŸ“ ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ ã¾ãŸã¯ ğŸ“· ã‚«ãƒ¡ãƒ©ã§æ’®å½±</h3>
            <p>4x4ã‚°ãƒªãƒƒãƒ‰ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®ç”»åƒã‚’ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã€é¸æŠã€ã¾ãŸã¯ã‚«ãƒ¡ãƒ©ã§æ’®å½±ã—ã¦ãã ã•ã„</p>
            <input type="file" id="imageInput" accept="image/*,.heic,.heif">
            <button class="camera-button" id="cameraButton">ğŸ“· ã‚«ãƒ¡ãƒ©ã‚’èµ·å‹•</button>

            <div id="cameraContainer" style="display: none;">
                <video id="cameraVideo" width="400" height="400" autoplay></video>
                <canvas id="cameraCanvas" width="400" height="400" style="display: none;"></canvas>
                <div class="camera-controls">
                    <button class="capture-button" id="captureButton">ğŸ“¸ æ’®å½±</button>
                    <button class="stop-camera-button" id="stopCameraButton">âŒ ã‚«ãƒ¡ãƒ©åœæ­¢</button>
                </div>
            </div>
        </div>

        <div id="status" class="status" style="display: none;"></div>

        <div class="preview-container" id="previewContainer" style="display: none;">
            <div class="image-preview">
                <h3>ğŸ“· ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç”»åƒ</h3>
                <img id="uploadedImage" alt="Uploaded image">
            </div>
            <div class="grid-preview">
                <h3>ğŸ¯ æ¤œå‡ºçµæœ</h3>
                <div class="grid-visualization" id="gridVisualization"></div>
                <button class="analyze-button" id="analyzeButton">ğŸ” ç”»åƒã‚’è§£æ</button>
            </div>
        </div>

        <div id="codeContainer" style="display: none;">
            <h3>ğŸ’» ç”Ÿæˆã•ã‚ŒãŸCSSã‚°ãƒªãƒƒãƒ‰ã‚³ãƒ¼ãƒ‰</h3>
            <div class="code-output" id="codeOutput"></div>
        </div>
    </div>

    <script>
        // ç”»åƒèªè­˜ç”¨ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°è¾æ›¸ (å¤‰æ›´ãªã—)
        const contentPatterns = {
            'logo-center': ['logo', 'ãƒ­ã‚´', 'LOGO'], // ä¸­å¤®é…ç½®ãƒ­ã‚´
            'logo-left': ['logo', 'ãƒ­ã‚´', 'LOGO'],   // å·¦é…ç½®ãƒ­ã‚´
            'sns': ['facebook', 'twitter', 'instagram', 'x', 'sns', 'SNS', 'f', 'ig'],
            'home': ['home', 'ãƒ›ãƒ¼ãƒ ', 'HOME'],
            'terms': ['åˆ©ç”¨è¦ç´„', 'è¦ç´„', 'terms'],
            'sitemap': ['ã‚µã‚¤ãƒˆãƒãƒƒãƒ—', 'sitemap', 'SITEMAP'],
            'privacy': ['ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ãƒãƒªã‚·ãƒ¼', 'privacy', 'ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼', 'ãƒãƒªã‚·ãƒ¼'],
            'phone': ['tel', 'TEL', '042', '637', '8111', 'é›»è©±'],
            'copyright': ['Â©', 'copyright', '2025', 'Â©2025'],
            // æ–°ã—ã„æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³
            'content_group': ['ã‚³ãƒ³ãƒ†ãƒ³ãƒ„', 'content'],
            'news': ['ãŠçŸ¥ã‚‰ã›', 'news', 'ãƒ‹ãƒ¥ãƒ¼ã‚¹'],
            'product': ['ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆ', 'product', 'è£½å“'],
            'support_group': ['ã‚µãƒãƒ¼ãƒˆ', 'support'],
            'contact': ['ãŠå•ã„åˆã‚ã›', 'contact', 'é€£çµ¡'],
            'faq': ['ã‚ˆãã‚ã‚‹è³ªå•', 'FAQ', 'faq', 'ã‚ˆãã‚ã‚‹'],
            'document': ['è³‡æ–™è«‹æ±‚', 'è³‡æ–™', 'document'],
            'policy_group': ['ãƒãƒªã‚·ãƒ¼', 'policy'],
            'cookie': ['cookieãƒãƒªã‚·ãƒ¼', 'cookie', 'ã‚¯ãƒƒã‚­ãƒ¼']
        };

        // ã‚«ãƒ¡ãƒ©é–¢é€£ã®å¤‰æ•°
        let cameraStream = null;
        let cameraVideo = null;
        let cameraCanvas = null;
        let cameraContext = null;

        // DOMè¦ç´ ã®å–å¾—ï¼ˆã‚«ãƒ¡ãƒ©é–¢é€£ã‚’è¿½åŠ ï¼‰
        const uploadArea = document.getElementById('uploadArea');
        const imageInput = document.getElementById('imageInput');
        const uploadedImage = document.getElementById('uploadedImage');
        const previewContainer = document.getElementById('previewContainer');
        const gridVisualization = document.getElementById('gridVisualization');
        const analyzeButton = document.getElementById('analyzeButton');
        const codeContainer = document.getElementById('codeContainer');
        const codeOutput = document.getElementById('codeOutput');
        const status = document.getElementById('status');
        const cameraButton = document.getElementById('cameraButton');
        const cameraContainer = document.getElementById('cameraContainer');
        const cameraVideoElement = document.getElementById('cameraVideo');
        const captureButton = document.getElementById('captureButton');
        const stopCameraButton = document.getElementById('stopCameraButton');
        const cameraCanvasElement = document.getElementById('cameraCanvas');

        // ã‚°ãƒªãƒƒãƒ‰ã®çŠ¶æ…‹ã‚’ä¿å­˜
        let gridData = Array(16).fill(null);
        let currentImage = null;

        // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºé–¢æ•° (å¤‰æ›´ãªã—)
        function showStatus(message, type = 'info') {
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';

            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    status.style.display = 'none';
                }, 3000);
            }
        }

        // ã‚°ãƒªãƒƒãƒ‰å¯è¦–åŒ–ã®åˆæœŸåŒ– (å¤‰æ›´ãªã—)
        function initializeGrid() {
            gridVisualization.innerHTML = '';
            for (let i = 0; i < 16; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.textContent = `${i + 1}`;
                cell.dataset.index = i;
                gridVisualization.appendChild(cell);
            }
        }

        // â˜…HEICå¯¾å¿œãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®èª­ã¿è¾¼ã¿ï¼ˆlibheif-jsã«åˆ‡ã‚Šæ›¿ãˆï¼‰â˜…
        async function loadHeifLibrary() {
            return new Promise((resolve, reject) => {
                if (window.HeifImage) {
                    resolve(window.HeifImage);
                    return;
                }

                const script = document.createElement('script');
                // libheif-js ã®CDNã‚’ä½¿ç”¨
                script.src = 'https://cdn.jsdelivr.net/npm/libheif-js@1.17.1/libheif-bundle.min.js';
                script.onload = () => {
                    if (window.HeifImage) {
                        resolve(window.HeifImage);
                    } else {
                        reject(new Error('HEICãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚'));
                    }
                };
                script.onerror = (error) => {
                    console.error('HEICãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                    reject(new Error('HEICãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚'));
                };
                document.head.appendChild(script);
            });
        }

        // â˜…ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å‡¦ç†ï¼ˆHEICå¯¾å¿œä¿®æ­£ç‰ˆ - libheif-jsã‚’ä½¿ç”¨ï¼‰â˜…
        async function handleFile(file) {
            if (!file.type.startsWith('image/') &&
                !file.name.toLowerCase().endsWith('.heic') &&
                !file.name.toLowerCase().endsWith('.heif')) {
                showStatus('å¯¾å¿œã—ã¦ã„ãªã„ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™ã€‚ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯HEICãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚', 'error');
                return;
            }

            let processedFile = file;
            let isHeic = file.name.toLowerCase().endsWith('.heic') || file.name.toLowerCase().endsWith('.heif');

            // HEIC/HEIFå½¢å¼ã®å¤‰æ›
            if (isHeic) {
                try {
                    showStatus('HEICå¤‰æ›ç”¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’èª­ã¿è¾¼ã¿ä¸­...', 'info');
                    const HeifImage = await loadHeifLibrary();

                    showStatus('HEICç”»åƒã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ä¸­...', 'info');
                    const buffer = await file.arrayBuffer();

                    const decoder = new HeifImage.HeifDecoder();
                    const images = decoder.decode(buffer);

                    if (images.length === 0) {
                        throw new Error("HEICãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ç”»åƒã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚");
                    }

                    // æœ€åˆã®ç”»åƒã‚’Canvasã«æç”»ã—ã¦JPEG Blobã«å¤‰æ›
                    const image = images[0];
                    const canvas = document.createElement('canvas');
                    canvas.width = image.get_width();
                    canvas.height = image.get_height();
                    const ctx = canvas.getContext('2d');

                    const imageData = ctx.createImageData(canvas.width, canvas.height);
                    imageData.data.set(new Uint8ClampedArray(image.get_data()));
                    ctx.putImageData(imageData, 0, 0);

                    processedFile = await new Promise(resolve => {
                        canvas.toBlob(resolve, 'image/jpeg', 0.9);
                    });

                    showStatus('HEICå¤‰æ›å®Œäº†ã€‚ç”»åƒã‚’èª­ã¿è¾¼ã¿ä¸­...', 'success');
                } catch (error) {
                    console.error('HEICå¤‰æ›ã‚¨ãƒ©ãƒ¼:', error);
                    showStatus(`HEICå¤‰æ›ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message ? error.message : 'ãƒ•ã‚¡ã‚¤ãƒ«è§£æã‚¨ãƒ©ãƒ¼'}ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ãŒç ´æã—ã¦ã„ã‚‹ã‹ã€æœªå¯¾å¿œã®HEICå½¢å¼ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚`, 'error');
                    return;
                }
            }

            const reader = new FileReader();
            reader.onload = function (e) {
                currentImage = e.target.result;
                uploadedImage.src = currentImage;
                previewContainer.style.display = 'block';
                initializeGrid();
                showStatus('ç”»åƒãŒèª­ã¿è¾¼ã¾ã‚Œã¾ã—ãŸã€‚è§£æãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚', 'success');
            };
            reader.onerror = function () {
                showStatus('ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚', 'error');
            };
            reader.readAsDataURL(processedFile);
        }

        // ã‚«ãƒ¡ãƒ©èµ·å‹• (å¤‰æ›´ãªã—)
        async function startCamera() {
            try {
                showStatus('ã‚«ãƒ¡ãƒ©ã‚’èµ·å‹•ä¸­...', 'info');
                cameraStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 400 },
                        height: { ideal: 400 },
                        aspectRatio: 1.0,
                        facingMode: 'environment' // èƒŒé¢ã‚«ãƒ¡ãƒ©ã‚’å„ªå…ˆ
                    }
                });

                cameraVideo = cameraVideoElement;
                cameraCanvas = cameraCanvasElement;
                cameraContext = cameraCanvas.getContext('2d');

                cameraVideo.srcObject = cameraStream;
                cameraContainer.style.display = 'block';
                cameraButton.style.display = 'none';

                showStatus('ã‚«ãƒ¡ãƒ©ãŒèµ·å‹•ã—ã¾ã—ãŸã€‚æ’®å½±ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚', 'success');
            } catch (error) {
                console.error('Camera error:', error);
                showStatus('ã‚«ãƒ¡ãƒ©ã®èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚', 'error');
            }
        }

        // å†™çœŸæ’®å½± (å¤‰æ›´ãªã—)
        function capturePhoto() {
            if (!cameraStream) return;

            cameraContext.drawImage(cameraVideo, 0, 0, 400, 400);
            cameraCanvas.toBlob(function (blob) {
                const file = new File([blob], 'camera-capture.jpg', { type: 'image/jpeg' });
                handleFile(file);
                stopCamera();
            }, 'image/jpeg', 0.9);
        }

        // ã‚«ãƒ¡ãƒ©åœæ­¢ (å¤‰æ›´ãªã—)
        function stopCamera() {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }
            cameraContainer.style.display = 'none';
            cameraButton.style.display = 'inline-block';
            showStatus('ã‚«ãƒ¡ãƒ©ã‚’åœæ­¢ã—ã¾ã—ãŸã€‚', 'info');
        }

        // 2æ®µéšç”»åƒè§£æï¼šä½™ç™½æ¤œå‡º â†’ ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ¤œå‡º (å¤‰æ›´ãªã—)
        function simulateAdvancedTextDetection(canvas) {
            return new Promise((resolve) => {
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                setTimeout(() => {
                    console.log('Phase 1: ä½™ç™½æ¤œå‡ºã‚’é–‹å§‹...');

                    // Phase 1: ä½™ç™½é ˜åŸŸã‚’ç‰¹å®š
                    const emptyAreas = detectEmptyAreas(imageData, canvas.width, canvas.height);

                    console.log('Phase 2: ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ¤œå‡ºã‚’é–‹å§‹...');

                    // Phase 2: ä½™ç™½ä»¥å¤–ã®é ˜åŸŸã§ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’æ¤œå‡º
                    const contentAreas = detectContentAreas(imageData, canvas.width, canvas.height, emptyAreas);

                    // æ¤œå‡ºã•ã‚ŒãŸã‚³ãƒ³ãƒ†ãƒ³ãƒ„é ˜åŸŸã‹ã‚‰ãƒ†ã‚­ã‚¹ãƒˆã‚’æŠ½å‡º
                    const detectedTexts = extractTextFromContentAreas(contentAreas);

                    console.log(`æ¤œå‡ºå®Œäº†: ${detectedTexts.length}å€‹ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ç™ºè¦‹`);

                    resolve(detectedTexts);
                }, 2000);
            });
        }

        // Phase 1: ä½™ç™½é ˜åŸŸã®æ¤œå‡ºï¼ˆä¿®æ­£ç‰ˆï¼‰(å¤‰æ›´ãªã—)
        function detectEmptyAreas(imageData, width, height) {
            const data = imageData.data;
            const emptyGrids = new Set();

            // 4x4ã‚°ãƒªãƒƒãƒ‰ã®å„ã‚»ãƒ«ã‚’åˆ†æ
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    const cellKey = `${row}-${col}`;

                    // Row 3ï¼ˆæœ€ä¸‹æ®µï¼‰ã¯ä½™ç™½åˆ¤å®šã‚’ã‚¹ã‚­ãƒƒãƒ—
                    if (row === 3) {
                        console.log(`ä½™ç™½åˆ¤å®šã‚¹ã‚­ãƒƒãƒ—: Row ${row + 1}, Col ${col + 1} (æœ€ä¸‹æ®µã¯å¸¸ã«ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ‰±ã„)`);
                        continue;
                    }

                    const isEmpty = analyzeCellForEmptiness(data, width, height, row, col);

                    // ä½™ç™½åˆ¤å®šåŸºæº–ã‚’ç·©å’Œï¼ˆ95% â†’ 85%ï¼‰
                    if (isEmpty.confidence > 0.85) {
                        emptyGrids.add(cellKey);
                        console.log(`ä½™ç™½æ¤œå‡º: Row ${row + 1}, Col ${col + 1} (ä¿¡é ¼åº¦: ${(isEmpty.confidence * 100).toFixed(1)}%)`);
                    } else {
                        console.log(`ã‚³ãƒ³ãƒ†ãƒ³ãƒ„å¯èƒ½æ€§: Row ${row + 1}, Col ${col + 1} (ä¿¡é ¼åº¦: ${(isEmpty.confidence * 100).toFixed(1)}%)`);
                    }
                }
            }

            return emptyGrids;
        }

        // ã‚»ãƒ«ã®ä½™ç™½åˆ¤å®šï¼ˆåŸºæº–ã‚’ç·©å’Œï¼‰(å¤‰æ›´ãªã—)
        function analyzeCellForEmptiness(data, width, height, row, col) {
            const cellWidth = Math.floor(width / 4);
            const cellHeight = Math.floor(height / 4);
            const startX = col * cellWidth;
            const startY = row * cellHeight;
            const endX = Math.min(startX + cellWidth, width);
            const endY = Math.min(startY + cellHeight, height);

            let backgroundPixels = 0;
            let contentPixels = 0;
            let totalPixels = 0;
            const colorCounts = new Map();
            const brightnessValues = [];

            // å…¨ãƒ”ã‚¯ã‚»ãƒ«ã‚’ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const i = (y * width + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const brightness = (r + g + b) / 3;

                    totalPixels++;
                    brightnessValues.push(brightness);

                    // èƒŒæ™¯è‰²åˆ¤å®šã‚’ç·©å’Œ
                    if (isLikelyBackground(r, g, b)) {
                        backgroundPixels++;
                    } else {
                        contentPixels++;
                    }

                    // è‰²ã®åˆ†å¸ƒã‚’è¨˜éŒ²
                    const colorKey = `${Math.floor(r / 15)}-${Math.floor(g / 15)}-${Math.floor(b / 15)}`;
                    colorCounts.set(colorKey, (colorCounts.get(colorKey) || 0) + 1);
                }
            }

            const backgroundRatio = backgroundPixels / totalPixels;
            const contentRatio = contentPixels / totalPixels;

            // è¼åº¦ã®çµ±ä¸€æ€§
            const avgBrightness = brightnessValues.reduce((a, b) => a + b, 0) / brightnessValues.length;
            const brightnessVariance = brightnessValues.reduce((acc, val) => acc + Math.pow(val - avgBrightness, 2), 0) / brightnessValues.length;
            const brightnessStdDev = Math.sqrt(brightnessVariance);

            // è‰²ã®çµ±ä¸€æ€§ï¼ˆè¨±å®¹ç¯„å›²ã‚’æ‹¡å¤§ï¼‰
            const uniqueColors = colorCounts.size;
            const maxExpectedColors = Math.max(totalPixels / 100, 10); // æœŸå¾…ã•ã‚Œã‚‹è‰²æ•°ã‚’å¢—åŠ 
            const colorUniformity = Math.max(0, 1 - (uniqueColors / maxExpectedColors));

            // è¼åº¦ã®çµ±ä¸€æ€§ï¼ˆåŸºæº–ã‚’ç·©å’Œï¼‰
            const brightnessUniformity = Math.max(0, 1 - (brightnessStdDev / 80)); // 80 â†’ ã‚ˆã‚Šå¯›å®¹ã«

            // ä½™ç™½ä¿¡é ¼åº¦ã®è¨ˆç®—ï¼ˆåŸºæº–ã‚’ç·©å’Œï¼‰
            const emptyConfidence = (
                backgroundRatio * 0.6 +           // èƒŒæ™¯æ¯”ç‡ã®é‡ã¿ã‚’å‰Šæ¸›
                colorUniformity * 0.25 +          // è‰²çµ±ä¸€æ€§ã®é‡ã¿ã‚’å‰Šæ¸›  
                brightnessUniformity * 0.15       // è¼åº¦çµ±ä¸€æ€§ã®é‡ã¿ã‚’å‰Šæ¸›
            ) - (contentRatio * 0.2);             // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒšãƒŠãƒ«ãƒ†ã‚£ã‚’å‰Šæ¸›

            return {
                confidence: Math.max(0, Math.min(emptyConfidence, 1.0)),
                backgroundRatio,
                contentRatio,
                colorUniformity,
                brightnessUniformity,
                uniqueColors,
                avgBrightness
            };
        }

        // èƒŒæ™¯è‰²ã®å¯èƒ½æ€§åˆ¤å®šï¼ˆç¯„å›²ã‚’æ‹¡å¤§ï¼‰(å¤‰æ›´ãªã—)
        function isLikelyBackground(r, g, b) {
            // ç™½ç³»ï¼ˆåŸºæº–ã‚’ç·©å’Œï¼‰
            const isWhitish = (r > 230 && g > 230 && b > 230);

            // ã‚°ãƒ¬ãƒ¼ç³»ï¼ˆç¯„å›²ã‚’æ‹¡å¤§ï¼‰
            const isGrayish = (
                Math.abs(r - g) < 25 && Math.abs(g - b) < 25 &&
                r > 180 && g > 180 && b > 180
            );

            // æœ¨ç›®èª¿ï¼ˆç¯„å›²ã‚’æ‹¡å¤§ï¼‰
            const isWoodish = (
                r >= 120 && r <= 220 &&
                g >= 100 && g <= 190 &&
                b >= 80 && b <= 160 &&
                (r - g) > -20 && (r - g) < 50 &&
                (g - b) > -10 && (g - b) < 60
            );

            // è–„ã„ãƒ™ãƒ¼ã‚¸ãƒ¥ç³»
            const isBeigeish = (
                r >= 200 && r <= 255 &&
                g >= 190 && g <= 240 &&
                b >= 170 && b <= 220 &&
                Math.abs(r - g) < 30 && Math.abs(g - b) < 30
            );

            return isWhitish || isGrayish || isWoodish || isBeigeish;
        }

        // ã‚ˆã‚Šç²¾å¯†ãªèƒŒæ™¯è‰²åˆ¤å®š (å¤‰æ›´ãªã—)
        function isUniformBackground(r, g, b) {
            // æœ¨ç›®èª¿ã®èŒ¶è‰²ç³»ï¼ˆç¯„å›²ã‚’ç‹­ã‚ã¦ç²¾åº¦å‘ä¸Šï¼‰
            const isWoodBrown = (r >= 130 && r <= 180 && g >= 90 && g <= 140 && b >= 50 && b <= 100);
            // æ˜ã‚‹ã„æœ¨ç›®
            const isLightWood = (r >= 180 && r <= 220 && g >= 140 && g <= 180 && b >= 100 && b <= 140);
            // ç™½ç³»èƒŒæ™¯
            const isWhite = (r > 245 && g > 245 && b > 245);
            // ã‚°ãƒ¬ãƒ¼ç³»ï¼ˆçµ±ä¸€æ€§é‡è¦–ï¼‰
            const isGray = (Math.abs(r - g) < 15 && Math.abs(g - b) < 15 && r > 220);

            return isWoodBrown || isLightWood || isWhite || isGray;
        }

        // Phase 2: ã‚³ãƒ³ãƒ†ãƒ³ãƒ„é ˜åŸŸã®æ¤œå‡ºï¼ˆåŸºæº–ã‚’ç·©å’Œï¼‰(å¤‰æ›´ãªã—)
        function detectContentAreas(imageData, width, height, emptyAreas) {
            const data = imageData.data;
            const contentAreas = [];

            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    const cellKey = `${row}-${col}`;

                    // ä½™ç™½ã¨ã—ã¦åˆ¤å®šã•ã‚ŒãŸé ˜åŸŸã¯ã‚¹ã‚­ãƒƒãƒ—
                    if (emptyAreas.has(cellKey)) {
                        console.log(`ä½™ç™½é ˜åŸŸã‚¹ã‚­ãƒƒãƒ—: Row ${row + 1}, Col ${col + 1}`);
                        continue;
                    }

                    const contentAnalysis = analyzeContentInCell(data, width, height, row, col);

                    // ä¿¡é ¼åº¦åŸºæº–ã‚’å¤§å¹…ã«ç·©å’Œï¼ˆ0.5 â†’ 0.2ï¼‰
                    if (contentAnalysis.hasContent && contentAnalysis.confidence > 0.2) {
                        contentAreas.push({
                            row,
                            col,
                            position: {
                                x: (col + 0.5) / 4,
                                y: (row + 0.5) / 4
                            },
                            ...contentAnalysis
                        });

                        console.log(`ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ¤œå‡º: Row ${row + 1}, Col ${col + 1} - ${contentAnalysis.contentType} (ä¿¡é ¼åº¦: ${(contentAnalysis.confidence * 100).toFixed(1)}%)`);
                    } else {
                        console.log(`ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãªã—: Row ${row + 1}, Col ${col + 1} - ä¿¡é ¼åº¦: ${(contentAnalysis.confidence * 100).toFixed(1)}%`);
                    }
                }
            }

            return contentAreas;
        }

        // ã‚»ãƒ«å†…ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„åˆ†æï¼ˆæ¤œå‡ºåŸºæº–ã‚’å¤§å¹…ç·©å’Œï¼‰(å¤‰æ›´ãªã—)
        function analyzeContentInCell(data, width, height, row, col) {
            const cellWidth = Math.floor(width / 4);
            const cellHeight = Math.floor(height / 4);
            const startX = col * cellWidth;
            const startY = row * cellHeight;
            const endX = Math.min(startX + cellWidth, width);
            const endY = Math.min(startY + cellHeight, height);

            let darkPixels = 0;
            let edgePixels = 0;
            let textLikeRegions = 0;
            let logoLikeRegions = 0;
            let nonBackgroundPixels = 0;
            const totalPixels = (endX - startX) * (endY - startY);

            // ãƒãƒ¼ã‚¸ãƒ³ã‚’å‰Šé™¤ã—ã¦å…¨é ˜åŸŸã‚’åˆ†æ
            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const i = (y * width + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const brightness = (r + g + b) / 3;

                    // èƒŒæ™¯è‰²ã§ãªã„ç”»ç´ ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
                    if (!isLikelyBackground(r, g, b)) {
                        nonBackgroundPixels++;

                        // æš—ã„ç”»ç´ ï¼ˆãƒ†ã‚­ã‚¹ãƒˆã‚„å›³å½¢ã®å¯èƒ½æ€§ï¼‰
                        if (brightness < 180) { // åŸºæº–ã‚’å¤§å¹…ç·©å’Œï¼ˆ150â†’180ï¼‰
                            darkPixels++;

                            // ãƒ­ã‚´ã£ã½ã„ãƒ‘ã‚¿ãƒ¼ãƒ³
                            if (hasLogoLikePattern(data, width, x, y)) {
                                logoLikeRegions++;
                            }

                            // ãƒ†ã‚­ã‚¹ãƒˆã£ã½ã„ãƒ‘ã‚¿ãƒ¼ãƒ³
                            if (hasTextLikePattern(data, width, x, y)) {
                                textLikeRegions++;
                            }
                        }
                    }

                    // ã‚¨ãƒƒã‚¸æ¤œå‡ºï¼ˆåŸºæº–ã‚’ç·©å’Œï¼‰
                    if (detectMediumEdge(data, width, x, y)) {
                        edgePixels++;
                    }
                }
            }

            const darkRatio = darkPixels / totalPixels;
            const edgeRatio = edgePixels / totalPixels;
            const textRatio = textLikeRegions / totalPixels;
            const logoRatio = logoLikeRegions / totalPixels;
            const nonBgRatio = nonBackgroundPixels / totalPixels;

            // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¤ãƒ—ã®åˆ¤å®šï¼ˆåŸºæº–ã‚’å¤§å¹…ç·©å’Œï¼‰
            let contentType = 'unknown';
            let hasContent = false;
            let confidence = 0;

            // ã‚ˆã‚Šå¯›å®¹ãªåˆ¤å®šåŸºæº–
            if (nonBgRatio > 0.02) { // èƒŒæ™¯ã§ãªã„ç”»ç´ ãŒ2%ä»¥ä¸Š
                hasContent = true;

                // ãƒ­ã‚´åˆ¤å®šï¼ˆä¸Šæ®µã§ã®å›³å½¢è¦ç´ ï¼‰
                if ((row === 0 || row === 1) && (logoRatio > 0.01 || darkRatio > 0.05)) {
                    contentType = 'logo';
                    confidence = Math.min((logoRatio * 20) + (darkRatio * 8) + (edgeRatio * 10), 1.0);
                }
                // ãƒ†ã‚­ã‚¹ãƒˆåˆ¤å®š
                else if (textRatio > 0.005 || darkRatio > 0.03) {
                    contentType = 'text';
                    confidence = Math.min((textRatio * 30) + (darkRatio * 10), 1.0);
                }
                // å›³å½¢åˆ¤å®š
                else if (edgeRatio > 0.02 || darkRatio > 0.02) {
                    contentType = 'graphic';
                    confidence = Math.min((edgeRatio * 15) + (darkRatio * 8), 1.0);
                }
                // ãã®ä»–ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„
                else {
                    contentType = 'mixed';
                    confidence = Math.min(nonBgRatio * 10, 1.0);
                }

                // æœ€ä½ä¿¡é ¼åº¦ã‚’ä¿è¨¼
                confidence = Math.max(confidence, nonBgRatio * 5);
            }

            console.log(`Content analysis [${row + 1}, ${col + 1}]: ${contentType}, nonBg=${(nonBgRatio * 100).toFixed(1)}%, dark=${(darkRatio * 100).toFixed(1)}%, edge=${(edgeRatio * 100).toFixed(1)}%, conf=${(confidence * 100).toFixed(1)}%`);

            return {
                hasContent,
                confidence,
                contentType,
                darkRatio,
                edgeRatio,
                textRatio,
                logoRatio,
                nonBgRatio
            };
        }

        // ä¸­ç¨‹åº¦ã®ã‚¨ãƒƒã‚¸æ¤œå‡ºï¼ˆã‚ˆã‚Šå¯›å®¹ï¼‰(å¤‰æ›´ãªã—)
        function detectMediumEdge(data, width, x, y) {
            if (x <= 0 || x >= width - 1 || y <= 0) return false;

            const current = (y * width + x) * 4;
            const right = (y * width + (x + 1)) * 4;
            const down = ((y + 1) * width + x) * 4;

            const currentBrightness = (data[current] + data[current + 1] + data[current + 2]) / 3;
            const rightBrightness = (data[right] + data[right + 1] + data[right + 2]) / 3;
            const downBrightness = (data[down] + data[down + 1] + data[down + 2]) / 3;

            const horizontalDiff = Math.abs(currentBrightness - rightBrightness);
            const verticalDiff = Math.abs(currentBrightness - downBrightness);

            return horizontalDiff > 40 || verticalDiff > 40; // é–¾å€¤ã‚’ä¸‹ã’ã¦æ¤œå‡ºã—ã‚„ã™ã
        }

        // ãƒ­ã‚´ã£ã½ã„ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œå‡º (å¤‰æ›´ãªã—)
        function hasLogoLikePattern(data, width, x, y) {
            const centerI = (y * width + x) * 4;
            const centerBrightness = (data[centerI] + data[centerI + 1] + data[centerI + 2]) / 3;

            if (centerBrightness > 120) return false; // æ˜ã‚‹ã™ãã‚‹ã¨ãƒ­ã‚´ã§ã¯ãªã„

            let similarDarkPixels = 0;
            const radius = 3; // æ¤œæŸ»ç¯„å›²

            // å‘¨å›²ã®ç”»ç´ ãŒä¼¼ãŸæ¿ƒã•ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆãƒ­ã‚´ã®å¡ŠçŠ¶ç‰¹å¾´ï¼‰
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < width && ny >= 0) {
                        const ni = (ny * width + nx) * 4;
                        const neighborBrightness = (data[ni] + data[ni + 1] + data[ni + 2]) / 3;

                        if (Math.abs(centerBrightness - neighborBrightness) < 40 && neighborBrightness < 150) {
                            similarDarkPixels++;
                        }
                    }
                }
            }

            return similarDarkPixels >= 12; // å‘¨å›²ã«ä¼¼ãŸæ¿ƒã„ç”»ç´ ãŒå¤šã„
        }

        // ãƒ†ã‚­ã‚¹ãƒˆã£ã½ã„ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œå‡º (å¤‰æ›´ãªã—)
        function hasTextLikePattern(data, width, x, y) {
            const centerI = (y * width + x) * 4;
            const centerBrightness = (data[centerI] + data[centerI + 1] + data[centerI + 2]) / 3;

            let contrastCount = 0;
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [1, 1], [-1, 1], [1, -1]];

            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                const ni = (ny * width + nx) * 4;
                const neighborBrightness = (data[ni] + data[ni + 1] + data[ni + 2]) / 3;

                if (Math.abs(centerBrightness - neighborBrightness) > 60) {
                    contrastCount++;
                }
            }

            return contrastCount >= 3; // 3æ–¹å‘ä»¥ä¸Šã§æ˜åº¦å·®ãŒã‚ã‚Œã°ãƒ†ã‚­ã‚¹ãƒˆã£ã½ã„
        }

        // å¼·ã„ã‚¨ãƒƒã‚¸ã®æ¤œå‡º (å¤‰æ›´ãªã—)
        function detectStrongEdge(data, width, x, y) {
            const current = (y * width + x) * 4;
            const right = (y * width + (x + 1)) * 4;
            const down = ((y + 1) * width + x) * 4;

            const currentBrightness = (data[current] + data[current + 1] + data[current + 2]) / 3;
            const rightBrightness = (data[right] + data[right + 1] + data[right + 2]) / 3;
            const downBrightness = (data[down] + data[down + 1] + data[down + 2]) / 3;

            const horizontalDiff = Math.abs(currentBrightness - rightBrightness);
            const verticalDiff = Math.abs(currentBrightness - downBrightness);

            return horizontalDiff > 80 || verticalDiff > 80; // é–¾å€¤ã‚’ä¸Šã’ã¦ç²¾åº¦å‘ä¸Š
        }

        // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„é ˜åŸŸã‹ã‚‰ãƒ†ã‚­ã‚¹ãƒˆã‚’æ¨å®šï¼ˆæ”¹è‰¯ç‰ˆï¼‰(å¤‰æ›´ãªã—)
        function extractTextFromContentAreas(contentAreas) {
            const detectedTexts = [];

            // å„ã‚³ãƒ³ãƒ†ãƒ³ãƒ„é ˜åŸŸã‚’é †ç•ªã«å‡¦ç†
            contentAreas.forEach(area => {
                const { row, col, confidence, contentType } = area;
                let estimatedText = null;
                let finalContentType = 'unknown';
                let colspan = 1;

                // ä½ç½®ãƒ™ãƒ¼ã‚¹ã®æ¨å®šï¼ˆã‚·ãƒ³ãƒ—ãƒ«åŒ–ï¼‰
                if ((row === 0 || row === 1) && (contentType === 'logo' || contentType === 'graphic')) {
                    // ãƒ­ã‚´æ¤œå‡º - ä½ç½®ã§é…ç½®ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
                    if (col === 0) {
                        estimatedText = 'Logo (Left)';
                        finalContentType = 'logo-left';
                        colspan = 2;
                    } else if (col >= 1 && col <= 2) {
                        estimatedText = 'Logo (Center)';
                        finalContentType = 'logo-center';
                        colspan = 2;
                    }
                }
                // 2æ®µç›®ãƒ»3æ®µç›®ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚°ãƒ«ãƒ¼ãƒ—
                else if (row === 1 && contentType === 'text') {
                    const contentGroups = ['ã‚³ãƒ³ãƒ†ãƒ³ãƒ„', 'ã‚µãƒãƒ¼ãƒˆ', 'ãƒãƒªã‚·ãƒ¼', null];
                    if (col < contentGroups.length && contentGroups[col]) {
                        estimatedText = contentGroups[col];
                        finalContentType = col === 0 ? 'content_group' :
                            col === 1 ? 'support_group' : 'policy_group';
                    }
                }
                // ãƒ•ãƒƒã‚¿ãƒ¼ãƒŠãƒ“
                else if (row === 2) {
                    const footerTexts = ['Home', 'ã‚µã‚¤ãƒˆãƒãƒƒãƒ—', 'ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ãƒãƒªã‚·ãƒ¼', 'åˆ©ç”¨è¦ç´„'];
                    const footerTypes = ['home', 'sitemap', 'privacy', 'terms'];
                    if (col < footerTexts.length) {
                        estimatedText = footerTexts[col];
                        finalContentType = footerTypes[col];
                    }
                }
                // ãƒœãƒˆãƒ æƒ…å ±
                else if (row === 3) {
                    if (col === 0 && (contentType === 'text' || contentType === 'graphic')) {
                        estimatedText = 'SNS';
                        finalContentType = 'sns';
                    } else if (col === 1 && contentType === 'text') {
                        estimatedText = 'TEL. 042-637-8111';
                        finalContentType = 'phone';
                    } else if (col === 2 && contentType === 'text') {
                        estimatedText = 'Â© 2025 Logo';
                        finalContentType = 'copyright';
                        // æ—¢ã«ã“ã®ãƒ­ã‚¸ãƒƒã‚¯ã§colspan=1ã ãŒã€getGridIndexAdvancedã§æœ€çµ‚æ±ºå®šã•ã‚Œã‚‹
                        colspan = 1;
                    }
                }

                if (estimatedText) {
                    detectedTexts.push({
                        text: estimatedText,
                        position: area.position,
                        width: colspan * 0.25,
                        height: 0.25,
                        confidence: confidence,
                        contentType: finalContentType,
                        row: row,
                        col: col,
                        colspan: colspan
                    });
                }
            });

            return detectedTexts;
        }

        // ç”»åƒç‰¹å¾´è§£æ (å¤‰æ›´ãªã—)
        function analyzeImageFeatures(imageData, baseDetections) {
            // ç°¡æ˜“çš„ãªè‰²å½©ãƒ»ã‚¨ãƒƒã‚¸è§£æã§æ¤œå‡ºç²¾åº¦ã‚’å‘ä¸Š
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;

            // ã‚¨ãƒªã‚¢åˆ¥ã®è‰²å½©åˆ†æã§è¦ç´ ã‚’è£œå¼·
            const enhancedDetections = [...baseDetections];

            // æœ¨ç›®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®æ¤œå‡ºï¼ˆèƒŒæ™¯èªè­˜ï¼‰
            const woodPattern = detectWoodTexture(data, width, height);
            if (woodPattern) {
                console.log('æœ¨ç›®èƒŒæ™¯ã‚’æ¤œå‡ºã—ã¾ã—ãŸ');
            }

            // ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ã®è¼åº¦åˆ†æ
            enhancedDetections.forEach(detection => {
                const brightness = analyzeAreaBrightness(data, width, height, detection.position);
                detection.confidence = brightness > 150 ? 0.9 : 0.7;
            });

            return enhancedDetections;
        }

        // æœ¨ç›®ãƒ†ã‚¯ã‚¹ãƒãƒ£æ¤œå‡º (å¤‰æ›´ãªã—)
        function detectWoodTexture(data, width, height) {
            let brownPixels = 0;
            const totalPixels = width * height;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];

                // èŒ¶è‰²ç³»ã®è‰²ã‚’æ¤œå‡º
                if (r > 120 && r < 200 && g > 80 && g < 150 && b > 40 && b < 120) {
                    brownPixels++;
                }
            }

            return (brownPixels / totalPixels) > 0.3;
        }

        // ã‚¨ãƒªã‚¢è¼åº¦åˆ†æ (å¤‰æ›´ãªã—)
        function analyzeAreaBrightness(data, width, height, position) {
            const startX = Math.floor(position.x * width);
            const startY = Math.floor(position.y * height);
            const endX = Math.min(startX + 50, width);
            const endY = Math.min(startY + 30, height);

            let totalBrightness = 0;
            let pixelCount = 0;

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const i = (y * width + x) * 4;
                    const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    totalBrightness += brightness;
                    pixelCount++;
                }
            }

            return pixelCount > 0 ? totalBrightness / pixelCount : 0;
        }

        // ä½ç½®ã‹ã‚‰4x4ã‚°ãƒªãƒƒãƒ‰ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¨ˆç®—ï¼ˆãƒ­ã‚´/ã‚³ãƒ”ãƒ¼ãƒ©ã‚¤ãƒˆã®åˆ¶ç´„ã‚’åæ˜ ï¼‰(å¤‰æ›´ãªã—)
        function getGridIndexAdvanced(x, y, width = 0.25, height = 0.25, text = '') {
            const col = Math.floor(x * 4);
            const row = Math.floor(y * 4);
            const baseIndex = Math.min(row * 4 + col, 15);

            const lowerText = text.toLowerCase();

            // 1. ã‚³ãƒ”ãƒ¼ãƒ©ã‚¤ãƒˆã¯å¸¸ã«1åˆ—ã€rowspan: 1ã‚’ä¿è¨¼
            if (lowerText.includes('copyright') || lowerText.includes('Â©')) {
                return {
                    index: baseIndex,
                    colspan: 1, // ã‚³ãƒ”ãƒ¼ãƒ©ã‚¤ãƒˆã¯å¸¸ã«1åˆ—
                    rowspan: 1, // ç¸¦ã‚¹ãƒ‘ãƒ³ã‚’æ’é™¤
                    type: 'copyright-single'
                };
            }

            // 2. ãƒ­ã‚´ã¯æ¨ªã«2åˆ—ï¼ˆcolspan: 2ï¼‰ã¯ã‚ã‚Šå¾—ã‚‹ãŒã€ç¸¦ã«2åˆ—ï¼ˆrowspan: 2ï¼‰ã¯çµ¶å¯¾ã«èµ·ã“ã‚‰ãªã„
            if (lowerText.includes('logo')) {
                return {
                    index: baseIndex,
                    colspan: 2, // æ¨ªã‚¹ãƒ‘ãƒ³ã¯ã‚ã‚Šå¾—ã‚‹
                    rowspan: 1, // ç¸¦ã‚¹ãƒ‘ãƒ³ã‚’çµ¶å¯¾ã«æ’é™¤
                    type: 'logo-span'
                };
            }

            // ãã®ä»–ã®è¦ç´ 
            return {
                index: baseIndex,
                colspan: 1,
                rowspan: 1,
                type: 'single'
            };
        }

        // ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š (å¤‰æ›´ãªã—)
        function classifyContent(text) {
            const lowerText = text.toLowerCase();

            for (const [contentType, patterns] of Object.entries(contentPatterns)) {
                for (const pattern of patterns) {
                    if (lowerText.includes(pattern.toLowerCase())) {
                        return contentType;
                    }
                }
            }
            return 'other';
        }

        // å®Ÿéš›ã®ç”»åƒè§£æï¼ˆé«˜ç²¾åº¦ç‰ˆï¼‰ (å¤‰æ›´ãªã—)
        async function analyzeImageContent() {
            if (!currentImage) {
                showStatus('ç”»åƒãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚', 'error');
                return;
            }

            showStatus('é«˜ç²¾åº¦ç”»åƒè§£æã‚’å®Ÿè¡Œä¸­...', 'info');
            analyzeButton.disabled = true;

            try {
                // Canvas ã§ç”»åƒã‚’å‡¦ç†
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();

                img.onload = async () => {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);

                    // é«˜ç²¾åº¦ãƒ†ã‚­ã‚¹ãƒˆæ¤œå‡º
                    const detectedTexts = await simulateAdvancedTextDetection(canvas);

                    // ã‚°ãƒªãƒƒãƒ‰ãƒ‡ãƒ¼ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆ
                    gridData = Array(16).fill(null);

                    // æ¤œå‡ºã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆã‚’å‡¦ç†
                    detectedTexts.forEach(detection => {
                        const gridInfo = getGridIndexAdvanced(
                            detection.position.x,
                            detection.position.y,
                            detection.width || 0.25,
                            detection.height || 0.25,
                            detection.text
                        );

                        const contentType = classifyContent(detection.text);

                        const gridEntry = {
                            type: contentType,
                            originalText: detection.text,
                            colspan: gridInfo.colspan,
                            rowspan: 1, // ã“ã“ã§ã‚‚æ˜ç¤ºçš„ã«1ã«å›ºå®šï¼ˆgetGridIndexAdvancedã®çµæœã‚’å°Šé‡ï¼‰
                            confidence: detection.confidence || 0.8
                        };

                        gridData[gridInfo.index] = gridEntry;

                        // ãƒ­ã‚´ãŒ2åˆ—åˆ†ã®å ´åˆã€æ¬¡ã®ã‚»ãƒ«ã‚‚ãƒãƒ¼ã‚¯
                        if (gridInfo.colspan === 2 && gridInfo.index % 4 < 3) {
                            gridData[gridInfo.index + 1] = {
                                ...gridEntry,
                                isSpanContinuation: true
                            };
                        }
                    });

                    updateGridVisualization();
                    generateAdvancedCode();
                    showStatus('é«˜ç²¾åº¦è§£æãŒå®Œäº†ã—ã¾ã—ãŸï¼', 'success');
                    analyzeButton.disabled = false;
                };

                img.src = currentImage;

            } catch (error) {
                showStatus('è§£æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', 'error');
                analyzeButton.disabled = false;
            }
        }

        // ã‚°ãƒªãƒƒãƒ‰å¯è¦–åŒ–ã®æ›´æ–°ï¼ˆ2åˆ—ãƒ­ã‚´å¯¾å¿œï¼‰(å¤‰æ›´ãªã—)
        function updateGridVisualization() {
            const cells = gridVisualization.querySelectorAll('.grid-cell');

            cells.forEach((cell, index) => {
                const data = gridData[index];
                cell.classList.remove('detected', 'logo-span', 'span-continuation');

                if (data) {
                    cell.classList.add('detected');

                    if (data.isSpanContinuation) {
                        cell.classList.add('span-continuation');
                        cell.textContent = 'â† Logoç¶šã';
                    } else {
                        if (data.colspan === 2) {
                            cell.classList.add('logo-span');
                            cell.textContent = `${data.originalText || data.type} (2åˆ—)`;
                        } else {
                            cell.textContent = data.originalText || data.type;
                        }

                        if (data.confidence) {
                            cell.title = `ä¿¡é ¼åº¦: ${Math.round(data.confidence * 100)}%`;
                        }
                    }
                } else {
                    cell.textContent = `${index + 1}`;
                    cell.title = '';
                }
            });
        }

        // é«˜ç²¾åº¦CSSã‚°ãƒªãƒƒãƒ‰ã‚³ãƒ¼ãƒ‰ç”Ÿæˆï¼ˆ2åˆ—ãƒ­ã‚´å¯¾å¿œï¼‰(å¤‰æ›´ãªã—)
        function generateAdvancedCode() {
            let html = '';
            let css = `/* CSS Grid Layout - é«˜ç²¾åº¦è§£æçµæœ */
.grid-container {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(4, 1fr);
    gap: 20px;
    padding: 20px;
    min-height: 100vh;
    background: linear-gradient(135deg, #8B4513 0%, #D2691E 100%);
}

`;

            const processedIndices = new Set();

            gridData.forEach((data, index) => {
                if (data && !processedIndices.has(index) && !data.isSpanContinuation) {
                    const row = Math.floor(index / 4) + 1;
                    const col = (index % 4) + 1;

                    let content = '';
                    let className = `grid-item-${index + 1}`;
                    let gridColumnSpan = data.colspan || 1;

                    switch (data.type) {
                        case 'logo-center':
                            content = `<div class="logo-container logo-center">
    <img src="logo-center.png" alt="Company Logo (Center)" class="logo-image">
</div>`;
                            break;
                        case 'logo-left':
                            content = `<div class="logo-container logo-left">
    <img src="logo-left.png" alt="Company Logo (Left)" class="logo-image">
</div>`;
                            break;
                        case 'sns':
                            content = `<div class="sns-container">
    <a href="#" class="sns-icon facebook" aria-label="Facebook">
        <i class="fab fa-facebook-f"></i>
    </a>
    <a href="#" class="sns-icon twitter" aria-label="Twitter">
        <i class="fab fa-x-twitter"></i>
    </a>
    <a href="#" class="sns-icon instagram" aria-label="Instagram">
        <i class="fab fa-instagram"></i>
    </a>
</div>`;
                            break;
                        case 'home':
                            content = `<a href="/" class="nav-link home">Home</a>`;
                            break;
                        case 'terms':
                            content = `<a href="/terms" class="nav-link terms">åˆ©ç”¨è¦ç´„</a>`;
                            break;
                        case 'sitemap':
                            content = `<a href="/sitemap" class="nav-link sitemap">ã‚µã‚¤ãƒˆãƒãƒƒãƒ—</a>`;
                            break;
                        case 'privacy':
                            content = `<a href="/privacy" class="nav-link privacy">ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ãƒãƒªã‚·ãƒ¼</a>`;
                            break;
                        case 'content_group':
                            content = `<div class="section-header">
    <h3>ã‚³ãƒ³ãƒ†ãƒ³ãƒ„</h3>
</div>`;
                            break;
                        case 'news':
                            content = `<a href="/news" class="nav-link news">ãŠçŸ¥ã‚‰ã›</a>`;
                            break;
                        case 'product':
                            content = `<a href="/products" class="nav-link products">ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆ</a>`;
                            break;
                        case 'support_group':
                            content = `<div class="section-header">
    <h3>ã‚µãƒãƒ¼ãƒˆ</h3>
</div>`;
                            break;
                        case 'contact':
                            content = `<a href="/contact" class="nav-link contact">ãŠå•ã„åˆã‚ã›</a>`;
                            break;
                        case 'faq':
                            content = `<a href="/faq" class="nav-link faq">ã‚ˆãã‚ã‚‹è³ªå•(FAQ)</a>`;
                            break;
                        case 'document':
                            content = `<a href="/documents" class="nav-link documents">è³‡æ–™è«‹æ±‚</a>`;
                            break;
                        case 'policy_group':
                            content = `<div class="section-header">
    <h3>ãƒãƒªã‚·ãƒ¼</h3>
</div>`;
                            break;
                        case 'cookie':
                            content = `<a href="/cookie-policy" class="nav-link cookie">cookieãƒãƒªã‚·ãƒ¼</a>`;
                            break;
                        case 'phone':
                            content = `<div class="contact-info">
    <a href="tel:042-637-8111" class="phone-link">
        <i class="fas fa-phone"></i> TEL. 042-637-8111
    </a>
</div>`;
                            break;
                        case 'copyright':
                            content = `<div class="copyright">
    <small>&copy; 2025 Logo</small>
</div>`;
                            break;
                        default:
                            content = `<div class="custom-content">${data.originalText}</div>`;
                    }

                    html += `    <div class="${className}">\n        ${content}\n    </div>\n`;

                    // CSSç”Ÿæˆ
                    css += `.${className} {
    grid-column: ${col}${gridColumnSpan > 1 ? ` / span ${gridColumnSpan}` : ''};
    grid-row: ${row}; /* ãƒ­ã‚´ã¨ã‚³ãƒ”ãƒ¼ãƒ©ã‚¤ãƒˆã®ç¸¦ã‚¹ãƒ‘ãƒ³ã‚’å¸¸ã«1ã«å›ºå®š */
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
}

`;

                    // å‡¦ç†æ¸ˆã¿ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ãƒãƒ¼ã‚¯
                    processedIndices.add(index);
                    if (gridColumnSpan > 1) {
                        for (let i = 1; i < gridColumnSpan; i++) {
                            processedIndices.add(index + i);
                        }
                    }
                }
            });

            // è¿½åŠ ã®ã‚¹ã‚¿ã‚¤ãƒªãƒ³ã‚°
            css += `
/* è¿½åŠ ã‚¹ã‚¿ã‚¤ãƒ« */
.logo-container {
    width: 100%;
}

.logo-image {
    max-width: 100%;
    height: auto;
    filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
}

.logo-center {
    text-align: center;
}

.logo-left {
    text-align: left;
}

.section-header {
    width: 100%;
    text-align: center;
    border-bottom: 2px solid #333;
    padding-bottom: 5px;
}

.section-header h3 {
    margin: 0;
    font-size: 1.1em;
    font-weight: bold;
    color: #333;
}

.sns-container {
    display: flex;
    gap: 15px;
    align-items: center;
}

.sns-icon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: #333;
    color: white;
    text-decoration: none;
    transition: transform 0.3s ease;
}

.sns-icon:hover {
    transform: scale(1.1);
}

.nav-link {
    color: #333;
    text-decoration: none;
    font-weight: 500;
    padding: 10px 20px;
    border-radius: 5px;
    transition: background-color 0.3s ease;
    display: block;
    width: 100%;
    text-align: center;
}

.nav-link:hover {
    background-color: rgba(255,255,255,0.2);
    transform: translateY(-1px);
}

.nav-link.news {
    border-left: 3px solid #ff9800;
}

.nav-link.products {
    border-left: 3px solid #2196f3;
}

.nav-link.contact {
    border-left: 3px solid #4caf50;
}

.nav-link.faq {
    border-left: 3px solid #9c27b0;
}

.nav-link.documents {
    border-left: 3px solid #f44336;
}

.nav-link.cookie {
    border-left: 3px solid #795548;
}

.contact-info {
    color: #333;
}

.phone-link {
    color: #333;
    text-decoration: none;
    font-weight: 500;
}

.phone-link:hover {
    color: #555;
}

.copyright {
    color: #666;
    font-size: 0.9em;
    text-align: center;
}

.custom-content {
    color: #333;
    font-weight: 500;
}
`;

            const fullCode = `<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generated Grid Layout - Enhanced</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
${css}
    </style>
</head>
<body>
    <div class="grid-container">
${html}    </div>
</body>
</html>`;

            codeOutput.textContent = fullCode;
            codeContainer.style.display = 'block';
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ (å¤‰æ›´ãªã—)
        imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleFile(file);
            }
        });

        // ã‚«ãƒ¡ãƒ©é–¢é€£ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ (å¤‰æ›´ãªã—)
        cameraButton.addEventListener('click', startCamera);
        captureButton.addEventListener('click', capturePhoto);
        stopCameraButton.addEventListener('click', stopCamera);

        // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ— (å¤‰æ›´ãªã—)
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) {
                handleFile(file);
            }
        });

        analyzeButton.addEventListener('click', analyzeImageContent);

        // åˆæœŸåŒ– (å¤‰æ›´ãªã—)
        initializeGrid();
    </script>
</body>

</html>