<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4x4 Grid Image Analyzer</title>
    <style>
        /* スタイルは変更なし */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s ease;
            background: #f8f9ff;
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: #f0f2ff;
        }

        .upload-area.dragover {
            border-color: #764ba2;
            background: #e8ecff;
        }

        input[type="file"] {
            margin: 20px 0;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
        }

        .preview-container {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
        }

        .image-preview,
        .grid-preview {
            flex: 1;
        }

        .image-preview img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }

        .grid-visualization {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            border: 2px solid #333;
            padding: 20px;
            background: #f9f9f9;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .grid-cell {
            aspect-ratio: 1;
            border: 2px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            text-align: center;
            background: white;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .grid-cell.logo-span {
            background: #e3f2fd;
            border-color: #1976d2;
            font-weight: bold;
            position: relative;
        }

        .grid-cell.span-continuation {
            background: #e8f5e8;
            border-color: #4caf50;
            font-size: 10px;
            opacity: 0.7;
        }

        .code-output {
            background: #1e1e1e;
            color: #fff;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .analyze-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: block;
            margin: 0 auto;
        }

        .analyze-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .camera-button,
        .capture-button,
        .stop-camera-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            margin: 10px 5px;
            transition: all 0.3s ease;
        }

        .camera-button:hover,
        .capture-button:hover,
        .stop-camera-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        #cameraContainer {
            margin-top: 20px;
            text-align: center;
        }

        #cameraVideo {
            border: 3px solid #667eea;
            border-radius: 10px;
            object-fit: cover;
        }

        .camera-controls {
            margin-top: 15px;
        }

        .status {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-weight: bold;
        }

        .status.success {
            background: #e8f5e8;
            color: #2e7d32;
            border: 2px solid #4caf50;
        }

        .status.error {
            background: #fce8e6;
            color: #c62828;
            border: 2px solid #f44336;
        }

        .status.info {
            background: #e3f2fd;
            color: #1565c0;
            border: 2px solid #2196f3;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>🎯 4x4 Grid Image Analyzer</h1>

        <div class="upload-area" id="uploadArea">
            <h3>📁 画像をアップロード または 📷 カメラで撮影</h3>
            <p>4x4グリッドレイアウトの画像をドラッグ&ドロップ、選択、またはカメラで撮影してください</p>
            <input type="file" id="imageInput" accept="image/*,.heic,.heif">
            <button class="camera-button" id="cameraButton">📷 カメラを起動</button>

            <div id="cameraContainer" style="display: none;">
                <video id="cameraVideo" width="400" height="400" autoplay></video>
                <canvas id="cameraCanvas" width="400" height="400" style="display: none;"></canvas>
                <div class="camera-controls">
                    <button class="capture-button" id="captureButton">📸 撮影</button>
                    <button class="stop-camera-button" id="stopCameraButton">❌ カメラ停止</button>
                </div>
            </div>
        </div>

        <div id="status" class="status" style="display: none;"></div>

        <div class="preview-container" id="previewContainer" style="display: none;">
            <div class="image-preview">
                <h3>📷 アップロード画像</h3>
                <img id="uploadedImage" alt="Uploaded image">
            </div>
            <div class="grid-preview">
                <h3>🎯 検出結果</h3>
                <div class="grid-visualization" id="gridVisualization"></div>
                <button class="analyze-button" id="analyzeButton">🔍 画像を解析</button>
            </div>
        </div>

        <div id="codeContainer" style="display: none;">
            <h3>💻 生成されたCSSグリッドコード</h3>
            <div class="code-output" id="codeOutput"></div>
        </div>
    </div>

    <script>
        // 画像認識用のパターンマッチング辞書 (変更なし)
        const contentPatterns = {
            'logo-center': ['logo', 'ロゴ', 'LOGO'], // 中央配置ロゴ
            'logo-left': ['logo', 'ロゴ', 'LOGO'],   // 左配置ロゴ
            'sns': ['facebook', 'twitter', 'instagram', 'x', 'sns', 'SNS', 'f', 'ig'],
            'home': ['home', 'ホーム', 'HOME'],
            'terms': ['利用規約', '規約', 'terms'],
            'sitemap': ['サイトマップ', 'sitemap', 'SITEMAP'],
            'privacy': ['プライバシーポリシー', 'privacy', 'プライバシー', 'ポリシー'],
            'phone': ['tel', 'TEL', '042', '637', '8111', '電話'],
            'copyright': ['©', 'copyright', '2025', '©2025'],
            // 新しい検出パターン
            'content_group': ['コンテンツ', 'content'],
            'news': ['お知らせ', 'news', 'ニュース'],
            'product': ['プロダクト', 'product', '製品'],
            'support_group': ['サポート', 'support'],
            'contact': ['お問い合わせ', 'contact', '連絡'],
            'faq': ['よくある質問', 'FAQ', 'faq', 'よくある'],
            'document': ['資料請求', '資料', 'document'],
            'policy_group': ['ポリシー', 'policy'],
            'cookie': ['cookieポリシー', 'cookie', 'クッキー']
        };

        // カメラ関連の変数
        let cameraStream = null;
        let cameraVideo = null;
        let cameraCanvas = null;
        let cameraContext = null;

        // DOM要素の取得（カメラ関連を追加）
        const uploadArea = document.getElementById('uploadArea');
        const imageInput = document.getElementById('imageInput');
        const uploadedImage = document.getElementById('uploadedImage');
        const previewContainer = document.getElementById('previewContainer');
        const gridVisualization = document.getElementById('gridVisualization');
        const analyzeButton = document.getElementById('analyzeButton');
        const codeContainer = document.getElementById('codeContainer');
        const codeOutput = document.getElementById('codeOutput');
        const status = document.getElementById('status');
        const cameraButton = document.getElementById('cameraButton');
        const cameraContainer = document.getElementById('cameraContainer');
        const cameraVideoElement = document.getElementById('cameraVideo');
        const captureButton = document.getElementById('captureButton');
        const stopCameraButton = document.getElementById('stopCameraButton');
        const cameraCanvasElement = document.getElementById('cameraCanvas');

        // グリッドの状態を保存
        let gridData = Array(16).fill(null);
        let currentImage = null;

        // ステータス表示関数 (変更なし)
        function showStatus(message, type = 'info') {
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';

            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    status.style.display = 'none';
                }, 3000);
            }
        }

        // グリッド可視化の初期化 (変更なし)
        function initializeGrid() {
            gridVisualization.innerHTML = '';
            for (let i = 0; i < 16; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.textContent = `${i + 1}`;
                cell.dataset.index = i;
                gridVisualization.appendChild(cell);
            }
        }

        // ★HEIC対応ライブラリの読み込み（libheif-jsに切り替え）★
        async function loadHeifLibrary() {
            return new Promise((resolve, reject) => {
                if (window.HeifImage) {
                    resolve(window.HeifImage);
                    return;
                }

                const script = document.createElement('script');
                // libheif-js のCDNを使用
                script.src = 'https://cdn.jsdelivr.net/npm/libheif-js@1.17.1/libheif-bundle.min.js';
                script.onload = () => {
                    if (window.HeifImage) {
                        resolve(window.HeifImage);
                    } else {
                        reject(new Error('HEICライブラリが見つかりませんでした。'));
                    }
                };
                script.onerror = (error) => {
                    console.error('HEICライブラリの読み込みエラー:', error);
                    reject(new Error('HEICライブラリの読み込みに失敗しました。'));
                };
                document.head.appendChild(script);
            });
        }

        // ★ファイルアップロード処理（HEIC対応修正版 - libheif-jsを使用）★
        async function handleFile(file) {
            if (!file.type.startsWith('image/') &&
                !file.name.toLowerCase().endsWith('.heic') &&
                !file.name.toLowerCase().endsWith('.heif')) {
                showStatus('対応していないファイル形式です。画像ファイルまたはHEICファイルを選択してください。', 'error');
                return;
            }

            let processedFile = file;
            let isHeic = file.name.toLowerCase().endsWith('.heic') || file.name.toLowerCase().endsWith('.heif');

            // HEIC/HEIF形式の変換
            if (isHeic) {
                try {
                    showStatus('HEIC変換用ライブラリを読み込み中...', 'info');
                    const HeifImage = await loadHeifLibrary();

                    showStatus('HEIC画像をデコード中...', 'info');
                    const buffer = await file.arrayBuffer();

                    const decoder = new HeifImage.HeifDecoder();
                    const images = decoder.decode(buffer);

                    if (images.length === 0) {
                        throw new Error("HEICファイルから画像をデコードできませんでした。");
                    }

                    // 最初の画像をCanvasに描画してJPEG Blobに変換
                    const image = images[0];
                    const canvas = document.createElement('canvas');
                    canvas.width = image.get_width();
                    canvas.height = image.get_height();
                    const ctx = canvas.getContext('2d');

                    const imageData = ctx.createImageData(canvas.width, canvas.height);
                    imageData.data.set(new Uint8ClampedArray(image.get_data()));
                    ctx.putImageData(imageData, 0, 0);

                    processedFile = await new Promise(resolve => {
                        canvas.toBlob(resolve, 'image/jpeg', 0.9);
                    });

                    showStatus('HEIC変換完了。画像を読み込み中...', 'success');
                } catch (error) {
                    console.error('HEIC変換エラー:', error);
                    showStatus(`HEIC変換に失敗しました: ${error.message ? error.message : 'ファイル解析エラー'}。ファイルが破損しているか、未対応のHEIC形式の可能性があります。`, 'error');
                    return;
                }
            }

            const reader = new FileReader();
            reader.onload = function (e) {
                currentImage = e.target.result;
                uploadedImage.src = currentImage;
                previewContainer.style.display = 'block';
                initializeGrid();
                showStatus('画像が読み込まれました。解析ボタンをクリックしてください。', 'success');
            };
            reader.onerror = function () {
                showStatus('ファイル読み込みに失敗しました。', 'error');
            };
            reader.readAsDataURL(processedFile);
        }

        // カメラ起動 (変更なし)
        async function startCamera() {
            try {
                showStatus('カメラを起動中...', 'info');
                cameraStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 400 },
                        height: { ideal: 400 },
                        aspectRatio: 1.0,
                        facingMode: 'environment' // 背面カメラを優先
                    }
                });

                cameraVideo = cameraVideoElement;
                cameraCanvas = cameraCanvasElement;
                cameraContext = cameraCanvas.getContext('2d');

                cameraVideo.srcObject = cameraStream;
                cameraContainer.style.display = 'block';
                cameraButton.style.display = 'none';

                showStatus('カメラが起動しました。撮影ボタンを押してください。', 'success');
            } catch (error) {
                console.error('Camera error:', error);
                showStatus('カメラの起動に失敗しました。ファイルアップロードをご利用ください。', 'error');
            }
        }

        // 写真撮影 (変更なし)
        function capturePhoto() {
            if (!cameraStream) return;

            cameraContext.drawImage(cameraVideo, 0, 0, 400, 400);
            cameraCanvas.toBlob(function (blob) {
                const file = new File([blob], 'camera-capture.jpg', { type: 'image/jpeg' });
                handleFile(file);
                stopCamera();
            }, 'image/jpeg', 0.9);
        }

        // カメラ停止 (変更なし)
        function stopCamera() {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }
            cameraContainer.style.display = 'none';
            cameraButton.style.display = 'inline-block';
            showStatus('カメラを停止しました。', 'info');
        }

        // 2段階画像解析：余白検出 → コンテンツ検出 (変更なし)
        function simulateAdvancedTextDetection(canvas) {
            return new Promise((resolve) => {
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                setTimeout(() => {
                    console.log('Phase 1: 余白検出を開始...');

                    // Phase 1: 余白領域を特定
                    const emptyAreas = detectEmptyAreas(imageData, canvas.width, canvas.height);

                    console.log('Phase 2: コンテンツ検出を開始...');

                    // Phase 2: 余白以外の領域でコンテンツを検出
                    const contentAreas = detectContentAreas(imageData, canvas.width, canvas.height, emptyAreas);

                    // 検出されたコンテンツ領域からテキストを抽出
                    const detectedTexts = extractTextFromContentAreas(contentAreas);

                    console.log(`検出完了: ${detectedTexts.length}個のコンテンツを発見`);

                    resolve(detectedTexts);
                }, 2000);
            });
        }

        // Phase 1: 余白領域の検出（修正版）(変更なし)
        function detectEmptyAreas(imageData, width, height) {
            const data = imageData.data;
            const emptyGrids = new Set();

            // 4x4グリッドの各セルを分析
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    const cellKey = `${row}-${col}`;

                    // Row 3（最下段）は余白判定をスキップ
                    if (row === 3) {
                        console.log(`余白判定スキップ: Row ${row + 1}, Col ${col + 1} (最下段は常にコンテンツ扱い)`);
                        continue;
                    }

                    const isEmpty = analyzeCellForEmptiness(data, width, height, row, col);

                    // 余白判定基準を緩和（95% → 85%）
                    if (isEmpty.confidence > 0.85) {
                        emptyGrids.add(cellKey);
                        console.log(`余白検出: Row ${row + 1}, Col ${col + 1} (信頼度: ${(isEmpty.confidence * 100).toFixed(1)}%)`);
                    } else {
                        console.log(`コンテンツ可能性: Row ${row + 1}, Col ${col + 1} (信頼度: ${(isEmpty.confidence * 100).toFixed(1)}%)`);
                    }
                }
            }

            return emptyGrids;
        }

        // セルの余白判定（基準を緩和）(変更なし)
        function analyzeCellForEmptiness(data, width, height, row, col) {
            const cellWidth = Math.floor(width / 4);
            const cellHeight = Math.floor(height / 4);
            const startX = col * cellWidth;
            const startY = row * cellHeight;
            const endX = Math.min(startX + cellWidth, width);
            const endY = Math.min(startY + cellHeight, height);

            let backgroundPixels = 0;
            let contentPixels = 0;
            let totalPixels = 0;
            const colorCounts = new Map();
            const brightnessValues = [];

            // 全ピクセルをサンプリング
            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const i = (y * width + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const brightness = (r + g + b) / 3;

                    totalPixels++;
                    brightnessValues.push(brightness);

                    // 背景色判定を緩和
                    if (isLikelyBackground(r, g, b)) {
                        backgroundPixels++;
                    } else {
                        contentPixels++;
                    }

                    // 色の分布を記録
                    const colorKey = `${Math.floor(r / 15)}-${Math.floor(g / 15)}-${Math.floor(b / 15)}`;
                    colorCounts.set(colorKey, (colorCounts.get(colorKey) || 0) + 1);
                }
            }

            const backgroundRatio = backgroundPixels / totalPixels;
            const contentRatio = contentPixels / totalPixels;

            // 輝度の統一性
            const avgBrightness = brightnessValues.reduce((a, b) => a + b, 0) / brightnessValues.length;
            const brightnessVariance = brightnessValues.reduce((acc, val) => acc + Math.pow(val - avgBrightness, 2), 0) / brightnessValues.length;
            const brightnessStdDev = Math.sqrt(brightnessVariance);

            // 色の統一性（許容範囲を拡大）
            const uniqueColors = colorCounts.size;
            const maxExpectedColors = Math.max(totalPixels / 100, 10); // 期待される色数を増加
            const colorUniformity = Math.max(0, 1 - (uniqueColors / maxExpectedColors));

            // 輝度の統一性（基準を緩和）
            const brightnessUniformity = Math.max(0, 1 - (brightnessStdDev / 80)); // 80 → より寛容に

            // 余白信頼度の計算（基準を緩和）
            const emptyConfidence = (
                backgroundRatio * 0.6 +           // 背景比率の重みを削減
                colorUniformity * 0.25 +          // 色統一性の重みを削減  
                brightnessUniformity * 0.15       // 輝度統一性の重みを削減
            ) - (contentRatio * 0.2);             // コンテンツペナルティを削減

            return {
                confidence: Math.max(0, Math.min(emptyConfidence, 1.0)),
                backgroundRatio,
                contentRatio,
                colorUniformity,
                brightnessUniformity,
                uniqueColors,
                avgBrightness
            };
        }

        // 背景色の可能性判定（範囲を拡大）(変更なし)
        function isLikelyBackground(r, g, b) {
            // 白系（基準を緩和）
            const isWhitish = (r > 230 && g > 230 && b > 230);

            // グレー系（範囲を拡大）
            const isGrayish = (
                Math.abs(r - g) < 25 && Math.abs(g - b) < 25 &&
                r > 180 && g > 180 && b > 180
            );

            // 木目調（範囲を拡大）
            const isWoodish = (
                r >= 120 && r <= 220 &&
                g >= 100 && g <= 190 &&
                b >= 80 && b <= 160 &&
                (r - g) > -20 && (r - g) < 50 &&
                (g - b) > -10 && (g - b) < 60
            );

            // 薄いベージュ系
            const isBeigeish = (
                r >= 200 && r <= 255 &&
                g >= 190 && g <= 240 &&
                b >= 170 && b <= 220 &&
                Math.abs(r - g) < 30 && Math.abs(g - b) < 30
            );

            return isWhitish || isGrayish || isWoodish || isBeigeish;
        }

        // より精密な背景色判定 (変更なし)
        function isUniformBackground(r, g, b) {
            // 木目調の茶色系（範囲を狭めて精度向上）
            const isWoodBrown = (r >= 130 && r <= 180 && g >= 90 && g <= 140 && b >= 50 && b <= 100);
            // 明るい木目
            const isLightWood = (r >= 180 && r <= 220 && g >= 140 && g <= 180 && b >= 100 && b <= 140);
            // 白系背景
            const isWhite = (r > 245 && g > 245 && b > 245);
            // グレー系（統一性重視）
            const isGray = (Math.abs(r - g) < 15 && Math.abs(g - b) < 15 && r > 220);

            return isWoodBrown || isLightWood || isWhite || isGray;
        }

        // Phase 2: コンテンツ領域の検出（基準を緩和）(変更なし)
        function detectContentAreas(imageData, width, height, emptyAreas) {
            const data = imageData.data;
            const contentAreas = [];

            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    const cellKey = `${row}-${col}`;

                    // 余白として判定された領域はスキップ
                    if (emptyAreas.has(cellKey)) {
                        console.log(`余白領域スキップ: Row ${row + 1}, Col ${col + 1}`);
                        continue;
                    }

                    const contentAnalysis = analyzeContentInCell(data, width, height, row, col);

                    // 信頼度基準を大幅に緩和（0.5 → 0.2）
                    if (contentAnalysis.hasContent && contentAnalysis.confidence > 0.2) {
                        contentAreas.push({
                            row,
                            col,
                            position: {
                                x: (col + 0.5) / 4,
                                y: (row + 0.5) / 4
                            },
                            ...contentAnalysis
                        });

                        console.log(`コンテンツ検出: Row ${row + 1}, Col ${col + 1} - ${contentAnalysis.contentType} (信頼度: ${(contentAnalysis.confidence * 100).toFixed(1)}%)`);
                    } else {
                        console.log(`コンテンツなし: Row ${row + 1}, Col ${col + 1} - 信頼度: ${(contentAnalysis.confidence * 100).toFixed(1)}%`);
                    }
                }
            }

            return contentAreas;
        }

        // セル内のコンテンツ分析（検出基準を大幅緩和）(変更なし)
        function analyzeContentInCell(data, width, height, row, col) {
            const cellWidth = Math.floor(width / 4);
            const cellHeight = Math.floor(height / 4);
            const startX = col * cellWidth;
            const startY = row * cellHeight;
            const endX = Math.min(startX + cellWidth, width);
            const endY = Math.min(startY + cellHeight, height);

            let darkPixels = 0;
            let edgePixels = 0;
            let textLikeRegions = 0;
            let logoLikeRegions = 0;
            let nonBackgroundPixels = 0;
            const totalPixels = (endX - startX) * (endY - startY);

            // マージンを削除して全領域を分析
            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const i = (y * width + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const brightness = (r + g + b) / 3;

                    // 背景色でない画素をカウント
                    if (!isLikelyBackground(r, g, b)) {
                        nonBackgroundPixels++;

                        // 暗い画素（テキストや図形の可能性）
                        if (brightness < 180) { // 基準を大幅緩和（150→180）
                            darkPixels++;

                            // ロゴっぽいパターン
                            if (hasLogoLikePattern(data, width, x, y)) {
                                logoLikeRegions++;
                            }

                            // テキストっぽいパターン
                            if (hasTextLikePattern(data, width, x, y)) {
                                textLikeRegions++;
                            }
                        }
                    }

                    // エッジ検出（基準を緩和）
                    if (detectMediumEdge(data, width, x, y)) {
                        edgePixels++;
                    }
                }
            }

            const darkRatio = darkPixels / totalPixels;
            const edgeRatio = edgePixels / totalPixels;
            const textRatio = textLikeRegions / totalPixels;
            const logoRatio = logoLikeRegions / totalPixels;
            const nonBgRatio = nonBackgroundPixels / totalPixels;

            // コンテンツタイプの判定（基準を大幅緩和）
            let contentType = 'unknown';
            let hasContent = false;
            let confidence = 0;

            // より寛容な判定基準
            if (nonBgRatio > 0.02) { // 背景でない画素が2%以上
                hasContent = true;

                // ロゴ判定（上段での図形要素）
                if ((row === 0 || row === 1) && (logoRatio > 0.01 || darkRatio > 0.05)) {
                    contentType = 'logo';
                    confidence = Math.min((logoRatio * 20) + (darkRatio * 8) + (edgeRatio * 10), 1.0);
                }
                // テキスト判定
                else if (textRatio > 0.005 || darkRatio > 0.03) {
                    contentType = 'text';
                    confidence = Math.min((textRatio * 30) + (darkRatio * 10), 1.0);
                }
                // 図形判定
                else if (edgeRatio > 0.02 || darkRatio > 0.02) {
                    contentType = 'graphic';
                    confidence = Math.min((edgeRatio * 15) + (darkRatio * 8), 1.0);
                }
                // その他のコンテンツ
                else {
                    contentType = 'mixed';
                    confidence = Math.min(nonBgRatio * 10, 1.0);
                }

                // 最低信頼度を保証
                confidence = Math.max(confidence, nonBgRatio * 5);
            }

            console.log(`Content analysis [${row + 1}, ${col + 1}]: ${contentType}, nonBg=${(nonBgRatio * 100).toFixed(1)}%, dark=${(darkRatio * 100).toFixed(1)}%, edge=${(edgeRatio * 100).toFixed(1)}%, conf=${(confidence * 100).toFixed(1)}%`);

            return {
                hasContent,
                confidence,
                contentType,
                darkRatio,
                edgeRatio,
                textRatio,
                logoRatio,
                nonBgRatio
            };
        }

        // 中程度のエッジ検出（より寛容）(変更なし)
        function detectMediumEdge(data, width, x, y) {
            if (x <= 0 || x >= width - 1 || y <= 0) return false;

            const current = (y * width + x) * 4;
            const right = (y * width + (x + 1)) * 4;
            const down = ((y + 1) * width + x) * 4;

            const currentBrightness = (data[current] + data[current + 1] + data[current + 2]) / 3;
            const rightBrightness = (data[right] + data[right + 1] + data[right + 2]) / 3;
            const downBrightness = (data[down] + data[down + 1] + data[down + 2]) / 3;

            const horizontalDiff = Math.abs(currentBrightness - rightBrightness);
            const verticalDiff = Math.abs(currentBrightness - downBrightness);

            return horizontalDiff > 40 || verticalDiff > 40; // 閾値を下げて検出しやすく
        }

        // ロゴっぽいパターンの検出 (変更なし)
        function hasLogoLikePattern(data, width, x, y) {
            const centerI = (y * width + x) * 4;
            const centerBrightness = (data[centerI] + data[centerI + 1] + data[centerI + 2]) / 3;

            if (centerBrightness > 120) return false; // 明るすぎるとロゴではない

            let similarDarkPixels = 0;
            const radius = 3; // 検査範囲

            // 周囲の画素が似た濃さかチェック（ロゴの塊状特徴）
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < width && ny >= 0) {
                        const ni = (ny * width + nx) * 4;
                        const neighborBrightness = (data[ni] + data[ni + 1] + data[ni + 2]) / 3;

                        if (Math.abs(centerBrightness - neighborBrightness) < 40 && neighborBrightness < 150) {
                            similarDarkPixels++;
                        }
                    }
                }
            }

            return similarDarkPixels >= 12; // 周囲に似た濃い画素が多い
        }

        // テキストっぽいパターンの検出 (変更なし)
        function hasTextLikePattern(data, width, x, y) {
            const centerI = (y * width + x) * 4;
            const centerBrightness = (data[centerI] + data[centerI + 1] + data[centerI + 2]) / 3;

            let contrastCount = 0;
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [1, 1], [-1, 1], [1, -1]];

            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                const ni = (ny * width + nx) * 4;
                const neighborBrightness = (data[ni] + data[ni + 1] + data[ni + 2]) / 3;

                if (Math.abs(centerBrightness - neighborBrightness) > 60) {
                    contrastCount++;
                }
            }

            return contrastCount >= 3; // 3方向以上で明度差があればテキストっぽい
        }

        // 強いエッジの検出 (変更なし)
        function detectStrongEdge(data, width, x, y) {
            const current = (y * width + x) * 4;
            const right = (y * width + (x + 1)) * 4;
            const down = ((y + 1) * width + x) * 4;

            const currentBrightness = (data[current] + data[current + 1] + data[current + 2]) / 3;
            const rightBrightness = (data[right] + data[right + 1] + data[right + 2]) / 3;
            const downBrightness = (data[down] + data[down + 1] + data[down + 2]) / 3;

            const horizontalDiff = Math.abs(currentBrightness - rightBrightness);
            const verticalDiff = Math.abs(currentBrightness - downBrightness);

            return horizontalDiff > 80 || verticalDiff > 80; // 閾値を上げて精度向上
        }

        // コンテンツ領域からテキストを推定（改良版）(変更なし)
        function extractTextFromContentAreas(contentAreas) {
            const detectedTexts = [];

            // 各コンテンツ領域を順番に処理
            contentAreas.forEach(area => {
                const { row, col, confidence, contentType } = area;
                let estimatedText = null;
                let finalContentType = 'unknown';
                let colspan = 1;

                // 位置ベースの推定（シンプル化）
                if ((row === 0 || row === 1) && (contentType === 'logo' || contentType === 'graphic')) {
                    // ロゴ検出 - 位置で配置タイプを判定
                    if (col === 0) {
                        estimatedText = 'Logo (Left)';
                        finalContentType = 'logo-left';
                        colspan = 2;
                    } else if (col >= 1 && col <= 2) {
                        estimatedText = 'Logo (Center)';
                        finalContentType = 'logo-center';
                        colspan = 2;
                    }
                }
                // 2段目・3段目のコンテンツグループ
                else if (row === 1 && contentType === 'text') {
                    const contentGroups = ['コンテンツ', 'サポート', 'ポリシー', null];
                    if (col < contentGroups.length && contentGroups[col]) {
                        estimatedText = contentGroups[col];
                        finalContentType = col === 0 ? 'content_group' :
                            col === 1 ? 'support_group' : 'policy_group';
                    }
                }
                // フッターナビ
                else if (row === 2) {
                    const footerTexts = ['Home', 'サイトマップ', 'プライバシーポリシー', '利用規約'];
                    const footerTypes = ['home', 'sitemap', 'privacy', 'terms'];
                    if (col < footerTexts.length) {
                        estimatedText = footerTexts[col];
                        finalContentType = footerTypes[col];
                    }
                }
                // ボトム情報
                else if (row === 3) {
                    if (col === 0 && (contentType === 'text' || contentType === 'graphic')) {
                        estimatedText = 'SNS';
                        finalContentType = 'sns';
                    } else if (col === 1 && contentType === 'text') {
                        estimatedText = 'TEL. 042-637-8111';
                        finalContentType = 'phone';
                    } else if (col === 2 && contentType === 'text') {
                        estimatedText = '© 2025 Logo';
                        finalContentType = 'copyright';
                        // 既にこのロジックでcolspan=1だが、getGridIndexAdvancedで最終決定される
                        colspan = 1;
                    }
                }

                if (estimatedText) {
                    detectedTexts.push({
                        text: estimatedText,
                        position: area.position,
                        width: colspan * 0.25,
                        height: 0.25,
                        confidence: confidence,
                        contentType: finalContentType,
                        row: row,
                        col: col,
                        colspan: colspan
                    });
                }
            });

            return detectedTexts;
        }

        // 画像特徴解析 (変更なし)
        function analyzeImageFeatures(imageData, baseDetections) {
            // 簡易的な色彩・エッジ解析で検出精度を向上
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;

            // エリア別の色彩分析で要素を補強
            const enhancedDetections = [...baseDetections];

            // 木目テクスチャの検出（背景認識）
            const woodPattern = detectWoodTexture(data, width, height);
            if (woodPattern) {
                console.log('木目背景を検出しました');
            }

            // テキストエリアの輝度分析
            enhancedDetections.forEach(detection => {
                const brightness = analyzeAreaBrightness(data, width, height, detection.position);
                detection.confidence = brightness > 150 ? 0.9 : 0.7;
            });

            return enhancedDetections;
        }

        // 木目テクスチャ検出 (変更なし)
        function detectWoodTexture(data, width, height) {
            let brownPixels = 0;
            const totalPixels = width * height;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];

                // 茶色系の色を検出
                if (r > 120 && r < 200 && g > 80 && g < 150 && b > 40 && b < 120) {
                    brownPixels++;
                }
            }

            return (brownPixels / totalPixels) > 0.3;
        }

        // エリア輝度分析 (変更なし)
        function analyzeAreaBrightness(data, width, height, position) {
            const startX = Math.floor(position.x * width);
            const startY = Math.floor(position.y * height);
            const endX = Math.min(startX + 50, width);
            const endY = Math.min(startY + 30, height);

            let totalBrightness = 0;
            let pixelCount = 0;

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const i = (y * width + x) * 4;
                    const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    totalBrightness += brightness;
                    pixelCount++;
                }
            }

            return pixelCount > 0 ? totalBrightness / pixelCount : 0;
        }

        // 位置から4x4グリッドのインデックス計算（ロゴ/コピーライトの制約を反映）(変更なし)
        function getGridIndexAdvanced(x, y, width = 0.25, height = 0.25, text = '') {
            const col = Math.floor(x * 4);
            const row = Math.floor(y * 4);
            const baseIndex = Math.min(row * 4 + col, 15);

            const lowerText = text.toLowerCase();

            // 1. コピーライトは常に1列、rowspan: 1を保証
            if (lowerText.includes('copyright') || lowerText.includes('©')) {
                return {
                    index: baseIndex,
                    colspan: 1, // コピーライトは常に1列
                    rowspan: 1, // 縦スパンを排除
                    type: 'copyright-single'
                };
            }

            // 2. ロゴは横に2列（colspan: 2）はあり得るが、縦に2列（rowspan: 2）は絶対に起こらない
            if (lowerText.includes('logo')) {
                return {
                    index: baseIndex,
                    colspan: 2, // 横スパンはあり得る
                    rowspan: 1, // 縦スパンを絶対に排除
                    type: 'logo-span'
                };
            }

            // その他の要素
            return {
                index: baseIndex,
                colspan: 1,
                rowspan: 1,
                type: 'single'
            };
        }

        // テキストからコンテンツタイプを判定 (変更なし)
        function classifyContent(text) {
            const lowerText = text.toLowerCase();

            for (const [contentType, patterns] of Object.entries(contentPatterns)) {
                for (const pattern of patterns) {
                    if (lowerText.includes(pattern.toLowerCase())) {
                        return contentType;
                    }
                }
            }
            return 'other';
        }

        // 実際の画像解析（高精度版） (変更なし)
        async function analyzeImageContent() {
            if (!currentImage) {
                showStatus('画像が選択されていません。', 'error');
                return;
            }

            showStatus('高精度画像解析を実行中...', 'info');
            analyzeButton.disabled = true;

            try {
                // Canvas で画像を処理
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();

                img.onload = async () => {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);

                    // 高精度テキスト検出
                    const detectedTexts = await simulateAdvancedTextDetection(canvas);

                    // グリッドデータをリセット
                    gridData = Array(16).fill(null);

                    // 検出されたテキストを処理
                    detectedTexts.forEach(detection => {
                        const gridInfo = getGridIndexAdvanced(
                            detection.position.x,
                            detection.position.y,
                            detection.width || 0.25,
                            detection.height || 0.25,
                            detection.text
                        );

                        const contentType = classifyContent(detection.text);

                        const gridEntry = {
                            type: contentType,
                            originalText: detection.text,
                            colspan: gridInfo.colspan,
                            rowspan: 1, // ここでも明示的に1に固定（getGridIndexAdvancedの結果を尊重）
                            confidence: detection.confidence || 0.8
                        };

                        gridData[gridInfo.index] = gridEntry;

                        // ロゴが2列分の場合、次のセルもマーク
                        if (gridInfo.colspan === 2 && gridInfo.index % 4 < 3) {
                            gridData[gridInfo.index + 1] = {
                                ...gridEntry,
                                isSpanContinuation: true
                            };
                        }
                    });

                    updateGridVisualization();
                    generateAdvancedCode();
                    showStatus('高精度解析が完了しました！', 'success');
                    analyzeButton.disabled = false;
                };

                img.src = currentImage;

            } catch (error) {
                showStatus('解析中にエラーが発生しました。', 'error');
                analyzeButton.disabled = false;
            }
        }

        // グリッド可視化の更新（2列ロゴ対応）(変更なし)
        function updateGridVisualization() {
            const cells = gridVisualization.querySelectorAll('.grid-cell');

            cells.forEach((cell, index) => {
                const data = gridData[index];
                cell.classList.remove('detected', 'logo-span', 'span-continuation');

                if (data) {
                    cell.classList.add('detected');

                    if (data.isSpanContinuation) {
                        cell.classList.add('span-continuation');
                        cell.textContent = '← Logo続き';
                    } else {
                        if (data.colspan === 2) {
                            cell.classList.add('logo-span');
                            cell.textContent = `${data.originalText || data.type} (2列)`;
                        } else {
                            cell.textContent = data.originalText || data.type;
                        }

                        if (data.confidence) {
                            cell.title = `信頼度: ${Math.round(data.confidence * 100)}%`;
                        }
                    }
                } else {
                    cell.textContent = `${index + 1}`;
                    cell.title = '';
                }
            });
        }

        // 高精度CSSグリッドコード生成（2列ロゴ対応）(変更なし)
        function generateAdvancedCode() {
            let html = '';
            let css = `/* CSS Grid Layout - 高精度解析結果 */
.grid-container {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(4, 1fr);
    gap: 20px;
    padding: 20px;
    min-height: 100vh;
    background: linear-gradient(135deg, #8B4513 0%, #D2691E 100%);
}

`;

            const processedIndices = new Set();

            gridData.forEach((data, index) => {
                if (data && !processedIndices.has(index) && !data.isSpanContinuation) {
                    const row = Math.floor(index / 4) + 1;
                    const col = (index % 4) + 1;

                    let content = '';
                    let className = `grid-item-${index + 1}`;
                    let gridColumnSpan = data.colspan || 1;

                    switch (data.type) {
                        case 'logo-center':
                            content = `<div class="logo-container logo-center">
    <img src="logo-center.png" alt="Company Logo (Center)" class="logo-image">
</div>`;
                            break;
                        case 'logo-left':
                            content = `<div class="logo-container logo-left">
    <img src="logo-left.png" alt="Company Logo (Left)" class="logo-image">
</div>`;
                            break;
                        case 'sns':
                            content = `<div class="sns-container">
    <a href="#" class="sns-icon facebook" aria-label="Facebook">
        <i class="fab fa-facebook-f"></i>
    </a>
    <a href="#" class="sns-icon twitter" aria-label="Twitter">
        <i class="fab fa-x-twitter"></i>
    </a>
    <a href="#" class="sns-icon instagram" aria-label="Instagram">
        <i class="fab fa-instagram"></i>
    </a>
</div>`;
                            break;
                        case 'home':
                            content = `<a href="/" class="nav-link home">Home</a>`;
                            break;
                        case 'terms':
                            content = `<a href="/terms" class="nav-link terms">利用規約</a>`;
                            break;
                        case 'sitemap':
                            content = `<a href="/sitemap" class="nav-link sitemap">サイトマップ</a>`;
                            break;
                        case 'privacy':
                            content = `<a href="/privacy" class="nav-link privacy">プライバシーポリシー</a>`;
                            break;
                        case 'content_group':
                            content = `<div class="section-header">
    <h3>コンテンツ</h3>
</div>`;
                            break;
                        case 'news':
                            content = `<a href="/news" class="nav-link news">お知らせ</a>`;
                            break;
                        case 'product':
                            content = `<a href="/products" class="nav-link products">プロダクト</a>`;
                            break;
                        case 'support_group':
                            content = `<div class="section-header">
    <h3>サポート</h3>
</div>`;
                            break;
                        case 'contact':
                            content = `<a href="/contact" class="nav-link contact">お問い合わせ</a>`;
                            break;
                        case 'faq':
                            content = `<a href="/faq" class="nav-link faq">よくある質問(FAQ)</a>`;
                            break;
                        case 'document':
                            content = `<a href="/documents" class="nav-link documents">資料請求</a>`;
                            break;
                        case 'policy_group':
                            content = `<div class="section-header">
    <h3>ポリシー</h3>
</div>`;
                            break;
                        case 'cookie':
                            content = `<a href="/cookie-policy" class="nav-link cookie">cookieポリシー</a>`;
                            break;
                        case 'phone':
                            content = `<div class="contact-info">
    <a href="tel:042-637-8111" class="phone-link">
        <i class="fas fa-phone"></i> TEL. 042-637-8111
    </a>
</div>`;
                            break;
                        case 'copyright':
                            content = `<div class="copyright">
    <small>&copy; 2025 Logo</small>
</div>`;
                            break;
                        default:
                            content = `<div class="custom-content">${data.originalText}</div>`;
                    }

                    html += `    <div class="${className}">\n        ${content}\n    </div>\n`;

                    // CSS生成
                    css += `.${className} {
    grid-column: ${col}${gridColumnSpan > 1 ? ` / span ${gridColumnSpan}` : ''};
    grid-row: ${row}; /* ロゴとコピーライトの縦スパンを常に1に固定 */
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
}

`;

                    // 処理済みインデックスをマーク
                    processedIndices.add(index);
                    if (gridColumnSpan > 1) {
                        for (let i = 1; i < gridColumnSpan; i++) {
                            processedIndices.add(index + i);
                        }
                    }
                }
            });

            // 追加のスタイリング
            css += `
/* 追加スタイル */
.logo-container {
    width: 100%;
}

.logo-image {
    max-width: 100%;
    height: auto;
    filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
}

.logo-center {
    text-align: center;
}

.logo-left {
    text-align: left;
}

.section-header {
    width: 100%;
    text-align: center;
    border-bottom: 2px solid #333;
    padding-bottom: 5px;
}

.section-header h3 {
    margin: 0;
    font-size: 1.1em;
    font-weight: bold;
    color: #333;
}

.sns-container {
    display: flex;
    gap: 15px;
    align-items: center;
}

.sns-icon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: #333;
    color: white;
    text-decoration: none;
    transition: transform 0.3s ease;
}

.sns-icon:hover {
    transform: scale(1.1);
}

.nav-link {
    color: #333;
    text-decoration: none;
    font-weight: 500;
    padding: 10px 20px;
    border-radius: 5px;
    transition: background-color 0.3s ease;
    display: block;
    width: 100%;
    text-align: center;
}

.nav-link:hover {
    background-color: rgba(255,255,255,0.2);
    transform: translateY(-1px);
}

.nav-link.news {
    border-left: 3px solid #ff9800;
}

.nav-link.products {
    border-left: 3px solid #2196f3;
}

.nav-link.contact {
    border-left: 3px solid #4caf50;
}

.nav-link.faq {
    border-left: 3px solid #9c27b0;
}

.nav-link.documents {
    border-left: 3px solid #f44336;
}

.nav-link.cookie {
    border-left: 3px solid #795548;
}

.contact-info {
    color: #333;
}

.phone-link {
    color: #333;
    text-decoration: none;
    font-weight: 500;
}

.phone-link:hover {
    color: #555;
}

.copyright {
    color: #666;
    font-size: 0.9em;
    text-align: center;
}

.custom-content {
    color: #333;
    font-weight: 500;
}
`;

            const fullCode = `<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generated Grid Layout - Enhanced</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
${css}
    </style>
</head>
<body>
    <div class="grid-container">
${html}    </div>
</body>
</html>`;

            codeOutput.textContent = fullCode;
            codeContainer.style.display = 'block';
        }

        // イベントリスナー (変更なし)
        imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleFile(file);
            }
        });

        // カメラ関連のイベントリスナー (変更なし)
        cameraButton.addEventListener('click', startCamera);
        captureButton.addEventListener('click', capturePhoto);
        stopCameraButton.addEventListener('click', stopCamera);

        // ドラッグ&ドロップ (変更なし)
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) {
                handleFile(file);
            }
        });

        analyzeButton.addEventListener('click', analyzeImageContent);

        // 初期化 (変更なし)
        initializeGrid();
    </script>
</body>

</html>